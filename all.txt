# Plik /Users/kfn/Desktop/DEV/sshManager/cmd/sshmen/main.go
package main

import (
	"flag"
	"fmt"
	"os"
	"sshManager/internal/config"
	"sshManager/internal/crypto"
	"sshManager/internal/ui"
	"sshManager/internal/ui/messages"
	"sshManager/internal/ui/views"

	tea "github.com/charmbracelet/bubbletea"
	"golang.org/x/term"
)

type mode int

const (
	modeConnect mode = iota
	modeEdit
	modeTransfer
)

type programModel struct {
	mode        mode
	quitting    bool
	uiModel     *ui.Model
	currentView tea.Model
	cipher      *crypto.Cipher
}

func initialModel() *programModel {
	uiModel := ui.NewModel()

	// Pobranie ścieżki do pliku konfiguracyjnego
	configPath, err := config.GetDefaultConfigPath()
	if err != nil {
		fmt.Printf("Warning: Could not determine config path: %v\n", err)
		configPath = config.DefaultConfigFileName
	}

	// Inicjalizacja widoku początkowego
	initialPrompt := views.NewInitialPromptModel(configPath)

	// Ustaw domyślny rozmiar terminala
	if w, h, err := term.GetSize(int(os.Stdout.Fd())); err == nil {
		uiModel.SetTerminalSize(w, h)
	}

	return &programModel{
		mode:        modeConnect,
		uiModel:     uiModel,
		currentView: initialPrompt,
	}
}
func (m *programModel) Init() tea.Cmd {
	return m.currentView.Init()
}

func (m *programModel) SetProgram(p *tea.Program) {
	if m.uiModel != nil {
		m.uiModel.SetProgram(p)
	}
}

func (m *programModel) updateCurrentView() {
	if m.cipher == nil {
		// Wciąż jesteśmy w widoku początkowym
		return
	}

	switch m.uiModel.GetActiveView() {
	case ui.ViewMain:
		m.currentView = views.NewMainView(m.uiModel)
	case ui.ViewEdit:
		m.currentView = views.NewEditView(m.uiModel)
	case ui.ViewTransfer:
		m.currentView = views.NewTransferView(m.uiModel)
	default:
		// Domyślnie ustaw widok główny
		m.currentView = views.NewMainView(m.uiModel)
		m.uiModel.SetActiveView(ui.ViewMain)
	}
}

func (m *programModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	// Sprawdź czy użytkownik chce zakończyć program
	if m.uiModel.IsQuitting() || m.quitting {
		return m, tea.Quit
	}

	switch msg := msg.(type) {
	case messages.PasswordEnteredMsg:
		// Inicjalizacja szyfru
		key := crypto.GenerateKeyFromPassword(string(msg))
		m.cipher = crypto.NewCipher(string(key))
		m.uiModel.SetCipher(m.cipher)

		// Przełączenie na główny widok
		m.updateCurrentView()

		// Inicjalizacja nowego widoku
		initCmd := m.currentView.Init()

		// Zwracamy model i komendę inicjalizującą
		return m, initCmd

	default:
		// Zapisz aktualny widok
		currentActiveView := m.uiModel.GetActiveView()

		// Aktualizuj obecny widok
		var cmd tea.Cmd
		m.currentView, cmd = m.currentView.Update(msg)

		// Sprawdź czy zmienił się aktywny widok
		if currentActiveView != m.uiModel.GetActiveView() {
			m.updateCurrentView()
		}

		return m, cmd
	}
}

func (m *programModel) View() string {
	if m.quitting || m.uiModel.IsQuitting() {
		return "Goodbye!\n"
	}
	return m.currentView.View()
}

func main() {
	// Parsowanie flag linii komend
	editMode := flag.Bool("edit", false, "Edit mode")
	transferMode := flag.Bool("file-transfer", false, "File transfer mode")
	flag.Parse()

	// Inicjalizacja modelu programu
	m := initialModel()

	// Ustawienie początkowego widoku na podstawie flag
	if *editMode {
		m.mode = modeEdit
		m.uiModel.SetActiveView(ui.ViewEdit)
	} else if *transferMode {
		m.mode = modeTransfer
		m.uiModel.SetActiveView(ui.ViewTransfer)
	}

	// Uruchomienie programu
	p := tea.NewProgram(m, tea.WithMouseCellMotion(), tea.WithAltScreen())
	m.SetProgram(p)
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error running program: %v", err)
		os.Exit(1)
	}
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/cmd/sshmen/main.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/config/config.go
// internal/config/config.go - zaktualizuj początek pliku

package config

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sshManager/internal/models"
)

const (
	DefaultConfigFileName = "ssh_hosts.json"
	DefaultConfigDir      = ".config/sshmen"
	DefaultFilePerms      = 0600
)

type Manager struct {
	configPath string
	config     *models.Config
}

// NewManager tworzy nowego menedżera konfiguracji
func NewManager(configPath string) *Manager {
	if configPath == "" {
		// Użyj GetDefaultConfigPath() do uzyskania ścieżki
		defaultPath, err := GetDefaultConfigPath()
		if err == nil {
			configPath = defaultPath
		} else {
			// Fallback do bieżącego katalogu jeśli nie można uzyskać ścieżki domowej
			configPath = DefaultConfigFileName
		}
	}

	return &Manager{
		configPath: configPath,
		config:     &models.Config{},
	}
}

// Load wczytuje konfigurację z pliku
func (m *Manager) Load() error {
	// Upewnij się, że katalog konfiguracyjny istnieje
	configDir := filepath.Dir(m.configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %v", err)
	}

	data, err := os.ReadFile(m.configPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			// Jeśli plik nie istnieje, tworzymy nową pustą konfigurację
			m.config = &models.Config{
				Hosts:     make([]models.Host, 0),
				Passwords: make([]models.Password, 0),
			}
			return m.Save() // Zapisujemy pustą konfigurację
		}
		return fmt.Errorf("failed to read config file: %v", err)
	}

	if err := json.Unmarshal(data, m.config); err != nil {
		return fmt.Errorf("failed to parse config file: %v", err)
	}

	return nil
}

// Save zapisuje konfigurację do pliku
func (m *Manager) Save() error {
	// Upewnij się, że katalog konfiguracyjny istnieje
	configDir := filepath.Dir(m.configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %v", err)
	}

	data, err := json.MarshalIndent(m.config, "", "    ")
	if err != nil {
		return fmt.Errorf("failed to marshal config: %v", err)
	}

	if err := os.WriteFile(m.configPath, data, DefaultFilePerms); err != nil {
		return fmt.Errorf("failed to write config file: %v", err)
	}

	return nil
}

// GetHosts zwraca listę wszystkich hostów
func (m *Manager) GetHosts() []models.Host {
	return m.config.Hosts
}

// AddHost dodaje nowego hosta
func (m *Manager) AddHost(host models.Host) {
	m.config.Hosts = append(m.config.Hosts, host)
}

// UpdateHost aktualizuje istniejącego hosta
func (m *Manager) UpdateHost(index int, host models.Host) error {
	if index < 0 || index >= len(m.config.Hosts) {
		return errors.New("invalid host index")
	}
	m.config.Hosts[index] = host
	return nil
}

// DeleteHost usuwa hosta
func (m *Manager) DeleteHost(index int) error {
	if index < 0 || index >= len(m.config.Hosts) {
		return errors.New("invalid host index")
	}
	m.config.Hosts = append(m.config.Hosts[:index], m.config.Hosts[index+1:]...)
	return nil
}

// GetPasswords zwraca listę wszystkich haseł
func (m *Manager) GetPasswords() []models.Password {
	return m.config.Passwords
}

// AddPassword dodaje nowe hasło
func (m *Manager) AddPassword(password models.Password) {
	m.config.Passwords = append(m.config.Passwords, password)
}

// UpdatePassword aktualizuje istniejące hasło
func (m *Manager) UpdatePassword(index int, password models.Password) error {
	if index < 0 || index >= len(m.config.Passwords) {
		return errors.New("invalid password index")
	}
	m.config.Passwords[index] = password
	return nil
}

// DeletePassword usuwa hasło
func (m *Manager) DeletePassword(index int) error {
	if index < 0 || index >= len(m.config.Passwords) {
		return errors.New("invalid password index")
	}
	// Sprawdzamy czy hasło nie jest używane przez żadnego hosta
	for _, host := range m.config.Hosts {
		if host.PasswordID == index {
			return errors.New("password is in use by a host")
		}
	}
	m.config.Passwords = append(m.config.Passwords[:index], m.config.Passwords[index+1:]...)
	return nil
}

// GetPassword zwraca hasło o danym indeksie
func (m *Manager) GetPassword(index int) (models.Password, error) {
	if index < 0 || index >= len(m.config.Passwords) {
		return models.Password{}, errors.New("invalid password index")
	}
	return m.config.Passwords[index], nil
}

// FindHostByName szuka hosta po nazwie
func (m *Manager) FindHostByName(name string) (models.Host, int, error) {
	for i, host := range m.config.Hosts {
		if host.Name == name {
			return host, i, nil
		}
	}
	return models.Host{}, -1, errors.New("host not found")
}

func GetDefaultConfigPath() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("could not get home directory: %v", err)
	}

	// Utwórz katalog konfiguracyjny jeśli nie istnieje
	configDir := filepath.Join(homeDir, DefaultConfigDir)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return "", fmt.Errorf("could not create config directory: %v", err)
	}

	return filepath.Join(configDir, DefaultConfigFileName), nil
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/config/config.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/crypto/crypto.go
// internal/crypto/crypto.go

package crypto

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"errors"

	"golang.org/x/crypto/nacl/secretbox"
)

const (
	keySize   = 32
	nonceSize = 24
)

type Cipher struct {
	key [keySize]byte
}

// NewCipher tworzy nowy obiekt szyfru z podanego hasła
func NewCipher(password string) *Cipher {
	// Generujemy klucz z hasła używając SHA-256
	h := sha256.New()
	h.Write([]byte(password))
	var key [keySize]byte
	copy(key[:], h.Sum(nil))

	return &Cipher{key: key}
}

// Encrypt szyfruje dane
func (c *Cipher) Encrypt(data string) (string, error) {
	// Generujemy nonce
	var nonce [nonceSize]byte
	if _, err := rand.Read(nonce[:]); err != nil {
		return "", err
	}

	// Szyfrujemy
	encrypted := secretbox.Seal(nonce[:], []byte(data), &nonce, &c.key)

	// Kodujemy do base64
	return base64.StdEncoding.EncodeToString(encrypted), nil
}

// Decrypt deszyfruje dane
func (c *Cipher) Decrypt(encryptedStr string) (string, error) {
	// Dekodujemy z base64
	encrypted, err := base64.StdEncoding.DecodeString(encryptedStr)
	if err != nil {
		return "", err
	}

	// Sprawdzamy czy dane są wystarczająco długie
	if len(encrypted) < nonceSize {
		return "", errors.New("encrypted data too short")
	}

	// Wyodrębniamy nonce
	var nonce [nonceSize]byte
	copy(nonce[:], encrypted[:nonceSize])

	// Deszyfrujemy
	decrypted, ok := secretbox.Open(nil, encrypted[nonceSize:], &nonce, &c.key)
	if !ok {
		return "", errors.New("decryption failed")
	}

	return string(decrypted), nil
}

// ValidateKey sprawdza czy klucz jest poprawny próbując odszyfrować przykładowe dane
func ValidateKey(cipher *Cipher, testData string) bool {
	encrypted, err := cipher.Encrypt("test")
	if err != nil {
		return false
	}

	decrypted, err := cipher.Decrypt(encrypted)
	if err != nil {
		return false
	}

	return decrypted == "test"
}

func GenerateKeyFromPassword(password string) []byte {
	// Dopełnij hasło do 32 bajtów
	paddedPass := make([]byte, 32)
	copy(paddedPass, []byte(password))

	// Zakoduj using base64
	return []byte(base64.URLEncoding.EncodeToString(paddedPass)[:32])
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/crypto/crypto.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/error/error.go
// internal/error/error.go

package error

import "fmt"

type AppError struct {
	Type    ErrorType
	Message string
	Err     error
}

type ErrorType int

const (
	ConfigError ErrorType = iota
	ConnectionError
	CryptoError
	FileError
	ValidationError
)

func (e *AppError) Error() string {
	if e.Err != nil {
		return fmt.Sprintf("%s: %v", e.Message, e.Err)
	}
	return e.Message
}

func New(errType ErrorType, message string, err error) *AppError {
	return &AppError{
		Type:    errType,
		Message: message,
		Err:     err,
	}
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/error/error.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/models/host.go
// internal/models/host.go

package models

type Host struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Login       string `json:"login"`
	IP          string `json:"ip"`
	Port        string `json:"port"`
	PasswordID  int    `json:"password_id"`
}

type Config struct {
	Hosts     []Host     `json:"hosts"`
	Passwords []Password `json:"passwords"`
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/models/host.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/models/password.go
// internal/models/password.go

package models

import (
	"errors"
	"sshManager/internal/crypto"
)

type Password struct {
	Description string `json:"description"`
	Password    string `json:"password"` // zaszyfrowane hasło
}

// NewPassword tworzy nową instancję Password
func NewPassword(description string, plainPassword string, cipher *crypto.Cipher) (*Password, error) {
	if description == "" {
		return nil, errors.New("description cannot be empty")
	}
	if plainPassword == "" {
		return nil, errors.New("password cannot be empty")
	}

	// Szyfrowanie hasła
	encryptedPass, err := cipher.Encrypt(plainPassword)
	if err != nil {
		return nil, err
	}

	return &Password{
		Description: description,
		Password:    encryptedPass,
	}, nil
}

// Validate sprawdza poprawność danych Password
func (p *Password) Validate() error {
	if p.Description == "" {
		return errors.New("description cannot be empty")
	}
	if p.Password == "" {
		return errors.New("password cannot be empty")
	}
	return nil
}

// GetDecrypted zwraca odszyfrowane hasło
func (p *Password) GetDecrypted(cipher *crypto.Cipher) (string, error) {
	return cipher.Decrypt(p.Password)
}

// UpdatePassword aktualizuje zaszyfrowane hasło
func (p *Password) UpdatePassword(newPlainPassword string, cipher *crypto.Cipher) error {
	if newPlainPassword == "" {
		return errors.New("new password cannot be empty")
	}

	encryptedPass, err := cipher.Encrypt(newPlainPassword)
	if err != nil {
		return err
	}

	p.Password = encryptedPass
	return nil
}

// UpdateDescription aktualizuje opis hasła
func (p *Password) UpdateDescription(newDescription string) error {
	if newDescription == "" {
		return errors.New("new description cannot be empty")
	}
	p.Description = newDescription
	return nil
}

// Clone tworzy kopię hasła
func (p *Password) Clone() *Password {
	return &Password{
		Description: p.Description,
		Password:    p.Password,
	}
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/models/password.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ssh/ssh_client.go
// internal/ssh/ssh_client.go

package ssh

import (
	"fmt"
	"os"
	"os/exec"
	"sshManager/internal/models"
)

type SSHClient struct {
	currentHost *models.Host
	passwords   []models.Password
}

func (s *SSHClient) GetPasswords() []models.Password {
	return s.passwords
}

func NewSSHClient(passwords []models.Password) *SSHClient {
	return &SSHClient{
		passwords: passwords,
	}
}

func CreateSSHCommand(host *models.Host, password string) *exec.Cmd {
	sshCommand := fmt.Sprintf(
		"clear; sshpass -p '%s' ssh -o StrictHostKeyChecking=no %s@%s -p %s; clear",
		password, host.Login, host.IP, host.Port,
	)
	cmd := exec.Command("sh", "-c", sshCommand)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd
}

func (s *SSHClient) Connect(host *models.Host, password string) error {
	fmt.Printf("\nConnecting to %s@%s...\n", host.Login, host.IP)
	cmd := CreateSSHCommand(host, password)
	s.currentHost = host
	return cmd.Run()
}

func (s *SSHClient) IsConnected() bool {
	return s.currentHost != nil
}

func (s *SSHClient) Disconnect() {
	s.currentHost = nil
}

func (s *SSHClient) GetCurrentHost() *models.Host {
	return s.currentHost
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ssh/ssh_client.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ssh/ssh_transfer.go
// internal/ssh/ssh_transfer.go

package ssh

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"sshManager/internal/crypto"
	"sshManager/internal/models"

	"github.com/pkg/sftp"
	"golang.org/x/crypto/ssh"
)

type FileTransfer struct {
	sftpClient  *sftp.Client
	sshClient   *ssh.Client // To jest natywny klient golang.org/x/crypto/ssh
	currentHost *models.Host
	cipher      *crypto.Cipher
	connected   bool
}

// TransferProgress reprezentuje postęp transferu pliku
type TransferProgress struct {
	FileName         string
	TotalBytes       int64
	TransferredBytes int64
	StartTime        time.Time
}

// NewFileTransfer tworzy nową instancję FileTransfer
func NewFileTransfer(cipher *crypto.Cipher) *FileTransfer {
	return &FileTransfer{
		cipher:    cipher,
		connected: false,
	}
}

// Connect nawiązuje połączenie SFTP
func (ft *FileTransfer) Connect(host *models.Host, password string) error {
	if ft.connected {
		return nil
	}

	config := &ssh.ClientConfig{
		User: host.Login,
		Auth: []ssh.AuthMethod{
			ssh.Password(password),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}

	addr := fmt.Sprintf("%s:%s", host.IP, host.Port)
	sshClient, err := ssh.Dial("tcp", addr, config)
	if err != nil {
		return fmt.Errorf("failed to dial: %v", err)
	}

	sftpClient, err := sftp.NewClient(sshClient)
	if err != nil {
		sshClient.Close()
		return fmt.Errorf("failed to create SFTP client: %v", err)
	}

	ft.sshClient = sshClient
	ft.sftpClient = sftpClient
	ft.currentHost = host
	ft.connected = true

	return nil
}

// Disconnect zamyka połączenie SFTP
func (ft *FileTransfer) Disconnect() error {
	if ft.sftpClient != nil {
		if err := ft.sftpClient.Close(); err != nil {
			return fmt.Errorf("error closing SFTP client: %v", err)
		}
		ft.sftpClient = nil
	}
	if ft.sshClient != nil {
		if err := ft.sshClient.Close(); err != nil {
			return fmt.Errorf("error closing SSH client: %v", err)
		}
		ft.sshClient = nil
	}
	ft.connected = false
	return nil
}

// ListLocalFiles zwraca listę plików w lokalnym katalogu
func (ft *FileTransfer) ListLocalFiles(path string) ([]os.FileInfo, error) {
	dir, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer dir.Close()

	return dir.Readdir(-1)
}

// ListRemoteFiles zwraca listę plików w zdalnym katalogu
func (ft *FileTransfer) ListRemoteFiles(path string) ([]os.FileInfo, error) {
	if !ft.connected {
		return nil, fmt.Errorf("not connected")
	}

	return ft.sftpClient.ReadDir(path)
}

// GetRemoteFileInfo zwraca informacje o zdalnym pliku
func (ft *FileTransfer) GetRemoteFileInfo(path string) (os.FileInfo, error) {
	if !ft.connected {
		return nil, fmt.Errorf("not connected")
	}

	return ft.sftpClient.Stat(path)
}

// CreateRemoteDirectory tworzy katalog na zdalnym serwerze
func (ft *FileTransfer) CreateRemoteDirectory(path string) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	return ft.sftpClient.MkdirAll(path)
}

// RemoveRemoteFile usuwa plik lub katalog na zdalnym serwerze
func (ft *FileTransfer) RemoveRemoteFile(path string) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	// Najpierw spróbuj usunąć jako plik
	err := ft.sftpClient.Remove(path)
	if err == nil {
		return nil
	}

	// Jeśli nie udało się usunąć jako pliku, spróbuj usunąć jako katalog
	return ft.sftpClient.RemoveDirectory(path)
}

// RenameRemoteFile zmienia nazwę pliku na zdalnym serwerze
func (ft *FileTransfer) RenameRemoteFile(oldPath, newPath string) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	return ft.sftpClient.Rename(oldPath, newPath)
}

func (ft *FileTransfer) IsConnected() bool {
	return ft.connected && ft.sftpClient != nil
}

// internal/ssh/ssh_transfer.go

func (ft *FileTransfer) UploadFile(localPath, remotePath string, progressChan chan<- TransferProgress) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	srcFile, err := os.Open(localPath)
	if err != nil {
		return fmt.Errorf("failed to open local file: %v", err)
	}
	defer srcFile.Close()

	dstFile, err := ft.sftpClient.Create(remotePath)
	if err != nil {
		return fmt.Errorf("failed to create remote file: %v", err)
	}
	defer dstFile.Close()

	fileInfo, err := srcFile.Stat()
	if err != nil {
		return fmt.Errorf("failed to get file info: %v", err)
	}

	progress := TransferProgress{
		FileName:   filepath.Base(localPath),
		TotalBytes: fileInfo.Size(),
		StartTime:  time.Now(),
	}

	bufSize := 128 * 1024 // Zwiększenie rozmiaru bufora do 128 KB
	buf := make([]byte, bufSize)
	for {
		n, err := srcFile.Read(buf)
		if err != nil && err != io.EOF {
			return fmt.Errorf("error reading local file: %v", err)
		}

		if n > 0 {
			written, writeErr := dstFile.Write(buf[:n])
			if writeErr != nil {
				return fmt.Errorf("error writing remote file: %v", writeErr)
			}
			if written != n {
				return fmt.Errorf("incomplete write: wrote %d bytes instead of %d", written, n)
			}

			progress.TransferredBytes += int64(n)
			if progressChan != nil {
				select {
				case progressChan <- progress:
				default:
				}
			}
		}

		if err == io.EOF {
			break
		}
	}

	// Upewnij się, że dane zostały zapisane na zdalnym dysku
	if err := dstFile.Sync(); err != nil {
		return fmt.Errorf("failed to sync remote file: %v", err)
	}

	// Wyślij końcową aktualizację postępu
	if progressChan != nil {
		select {
		case progressChan <- progress:
		default:
		}
	}

	return nil
}

// internal/ssh/ssh_transfer.go

func (ft *FileTransfer) DownloadFile(remotePath, localPath string, progressChan chan<- TransferProgress) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	srcFile, err := ft.sftpClient.Open(remotePath)
	if err != nil {
		return fmt.Errorf("failed to open remote file: %v", err)
	}
	defer srcFile.Close()

	dstFile, err := os.Create(localPath)
	if err != nil {
		return fmt.Errorf("failed to create local file: %v", err)
	}
	defer dstFile.Close()

	fileInfo, err := srcFile.Stat()
	if err != nil {
		return fmt.Errorf("failed to get file info: %v", err)
	}

	progress := TransferProgress{
		FileName:   filepath.Base(remotePath),
		TotalBytes: fileInfo.Size(),
		StartTime:  time.Now(),
	}

	bufSize := 128 * 1024 // Zwiększenie rozmiaru bufora do 128 KB
	buf := make([]byte, bufSize)
	for {
		n, err := srcFile.Read(buf)
		if err != nil && err != io.EOF {
			return fmt.Errorf("error reading remote file: %v", err)
		}

		if n > 0 {
			written, writeErr := dstFile.Write(buf[:n])
			if writeErr != nil {
				return fmt.Errorf("error writing local file: %v", writeErr)
			}
			if written != n {
				return fmt.Errorf("incomplete write: wrote %d bytes instead of %d", written, n)
			}

			progress.TransferredBytes += int64(n)
			if progressChan != nil {
				select {
				case progressChan <- progress:
				default:
				}
			}
		}

		if err == io.EOF {
			break
		}
	}

	// Upewnij się, że dane zostały zapisane na lokalnym dysku
	if err := dstFile.Sync(); err != nil {
		return fmt.Errorf("failed to sync local file: %v", err)
	}

	// Wyślij końcową aktualizację postępu
	if progressChan != nil {
		select {
		case progressChan <- progress:
		default:
		}
	}

	return nil
}

// Dodaj na końcu pliku internal/ssh/ssh_transfer.go

func (ft *FileTransfer) GetRemoteHomeDir() (string, error) {
	if !ft.connected {
		return "", fmt.Errorf("not connected")
	}

	session, err := ft.sshClient.NewSession()
	if err != nil {
		return "", fmt.Errorf("failed to create session: %v", err)
	}
	defer session.Close()

	output, err := session.Output("echo $HOME")
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %v", err)
	}

	// Usuń znak nowej linii z końca
	homeDir := strings.TrimSpace(string(output))
	return homeDir, nil
}

// RemoveRemoteDirectoryRecursive usuwa katalog rekursywnie
func (ft *FileTransfer) RemoveRemoteDirectoryRecursive(path string) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	entries, err := ft.ListRemoteFiles(path)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	for _, entry := range entries {
		if entry.Name() == "." || entry.Name() == ".." {
			continue
		}

		fullPath := filepath.Join(path, entry.Name())
		if entry.IsDir() {
			if err := ft.RemoveRemoteDirectoryRecursive(fullPath); err != nil {
				return err
			}
		} else {
			if err := ft.RemoveRemoteFile(fullPath); err != nil {
				return err
			}
		}
	}

	return ft.sftpClient.RemoveDirectory(path)
}

// UploadDirectory kopiuje cały katalog na serwer
func (ft *FileTransfer) UploadDirectory(localPath, remotePath string, progressChan chan<- TransferProgress) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	if err := ft.CreateRemoteDirectory(remotePath); err != nil {
		return fmt.Errorf("failed to create remote directory: %v", err)
	}

	return filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(localPath, path)
		if err != nil {
			return err
		}

		remotePathFull := filepath.Join(remotePath, relPath)

		if info.IsDir() {
			return ft.CreateRemoteDirectory(remotePathFull)
		}
		return ft.UploadFile(path, remotePathFull, progressChan)
	})
}

// DownloadDirectory kopiuje cały katalog z serwera
func (ft *FileTransfer) DownloadDirectory(remotePath, localPath string, progressChan chan<- TransferProgress) error {
	if !ft.connected {
		return fmt.Errorf("not connected")
	}

	if err := os.MkdirAll(localPath, 0755); err != nil {
		return fmt.Errorf("failed to create local directory: %v", err)
	}

	entries, err := ft.ListRemoteFiles(remotePath)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	for _, entry := range entries {
		if entry.Name() == "." || entry.Name() == ".." {
			continue
		}

		remoteSrcPath := filepath.Join(remotePath, entry.Name())
		localDstPath := filepath.Join(localPath, entry.Name())

		if entry.IsDir() {
			if err := ft.DownloadDirectory(remoteSrcPath, localDstPath, progressChan); err != nil {
				return err
			}
		} else {
			if err := ft.DownloadFile(remoteSrcPath, localDstPath, progressChan); err != nil {
				return err
			}
		}
	}

	return nil
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ssh/ssh_transfer.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/messages/messages.go
// internal/ui/messages/messages.go

package messages

type PasswordEnteredMsg string

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/messages/messages.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/models.go
// internal/ui/models.go

package ui

import (
	"fmt"
	"os"
	"sshManager/internal/config"
	"sshManager/internal/crypto"
	"sshManager/internal/models"
	"sshManager/internal/ssh"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"golang.org/x/term"
)

// KeyMap definiuje skróty klawiszowe
type KeyMap struct {
	Up       key.Binding
	Down     key.Binding
	Enter    key.Binding
	Back     key.Binding
	Quit     key.Binding
	Edit     key.Binding
	Connect  key.Binding
	Transfer key.Binding
	Refresh  key.Binding
}

// DefaultKeyMap zwraca domyślne ustawienia klawiszy
func DefaultKeyMap() KeyMap {
	return KeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Enter: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "select"),
		),
		Back: key.NewBinding(
			key.WithKeys("esc"),
			key.WithHelp("esc", "back"),
		),
		Quit: key.NewBinding(
			key.WithKeys("q", "ctrl+c"),
			key.WithHelp("q", "quit"),
		),
		Edit: key.NewBinding(
			key.WithKeys("e"),
			key.WithHelp("e", "edit"),
		),
		Connect: key.NewBinding(
			key.WithKeys("c"),
			key.WithHelp("c", "connect"),
		),
		Transfer: key.NewBinding(
			key.WithKeys("t"),
			key.WithHelp("t", "transfer"),
		),
		Refresh: key.NewBinding(
			key.WithKeys("r"),
			key.WithHelp("r", "refresh"),
		),
	}
}

// Status reprezentuje stan aplikacji
type Status struct {
	Message string
	IsError bool
}

type View int

const (
	ViewMain View = iota
	ViewConnect
	ViewEdit
	ViewTransfer
	ViewHostList
	ViewPasswordList
	ViewHostEdit
	ViewPasswordEdit
)

// Model reprezentuje główny model aplikacji
type Model struct {
	keys           KeyMap
	status         Status
	activeView     View
	sshClient      *ssh.SSHClient // tylko dla trybu SSH
	transfer       *ssh.FileTransfer
	hosts          []models.Host
	passwords      []models.Password
	selectedHost   *models.Host
	hostList       list.Model
	passwordList   list.Model
	input          textinput.Model
	width          int
	height         int
	quitting       bool
	config         *config.Manager
	cipher         *crypto.Cipher
	Program        *tea.Program // Zmiana z małej litery na wielką
	terminalWidth  int
	terminalHeight int
	selectedItems  map[string]bool // mapa przechowująca zaznaczone elementy (klucz: ścieżka pliku)

}

// Init implementuje tea.Model
func (m Model) Init() tea.Cmd {
	return textinput.Blink
}

func (m *Model) SetProgram(p *tea.Program) {
	m.Program = p
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			m.DisconnectHost() // Zamknij połączenie przed wyjściem
			m.quitting = true
			return m, tea.Quit
		case "c":
			if m.activeView == ViewMain {
				m.activeView = ViewHostList
				return m, nil
			}
		case "esc":
			if m.activeView != ViewMain {
				m.activeView = ViewMain
				return m, nil
			}
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.hostList.SetWidth(msg.Width)
		m.hostList.SetHeight(msg.Height - 4)
		m.passwordList.SetWidth(msg.Width)
		m.passwordList.SetHeight(msg.Height - 4)
	}

	// Aktualizacja aktywnego widoku
	switch m.activeView {
	case ViewHostList:
		newListModel, cmd := m.hostList.Update(msg)
		m.hostList = newListModel
		if item, ok := m.hostList.SelectedItem().(HostItem); ok {
			m.selectedHost = &item.host
		}
		return m, cmd
	case ViewPasswordList:
		newListModel, cmd := m.passwordList.Update(msg)
		m.passwordList = newListModel
		return m, cmd
	}

	return m, cmd
}

// View implementuje tea.Model
func (m Model) View() string {
	if m.quitting {
		return "Do widzenia!\n"
	}

	var view string
	switch m.activeView {
	case ViewMain:
		view = m.viewMain()
	case ViewHostList:
		view = m.hostList.View()
	case ViewPasswordList:
		view = m.passwordList.View()
	}

	// Dodaj status jeśli istnieje
	if m.status.Message != "" {
		style := SuccessStyle
		if m.status.IsError {
			style = ErrorStyle
		}
		view += "\n" + style.Render(m.status.Message)
	}

	return view
}

// viewMain renderuje główny widok
func (m Model) viewMain() string {
	return WindowStyle.Render(
		TitleStyle.Render("SSH Manager") + "\n\n" +
			"c - Połącz\n" +
			"e - Edytuj\n" +
			"t - Transfer plików\n" +
			"q - Wyjście",
	)
}

func NewModel() *Model {
	// Pobierz aktualny rozmiar terminala
	width, height, _ := term.GetSize(int(os.Stdout.Fd()))

	configPath, err := config.GetDefaultConfigPath()
	if err != nil {
		configPath = config.DefaultConfigFileName
	}

	configManager := config.NewManager(configPath)

	m := Model{
		keys:           DefaultKeyMap(),
		activeView:     ViewMain,
		input:          textinput.New(),
		hostList:       initializeList("Hosty"),
		passwordList:   initializeList("Hasła"),
		config:         configManager,
		terminalWidth:  width,  // Dodane
		terminalHeight: height, // Dodane
		selectedItems:  make(map[string]bool),
	}

	// Wczytaj zapisaną konfigurację
	if err := configManager.Load(); err != nil {
		m.SetStatus(fmt.Sprintf("Warning: %v", err), true)
	}

	// Załaduj dane do modelu
	m.hosts = configManager.GetHosts()
	m.passwords = configManager.GetPasswords()
	m.UpdateLists()
	m.selectedItems = make(map[string]bool)

	return &m // Zwracamy wskaźnik do m
}

func (m *Model) SaveConfig() interface{} {
	if err := m.config.Save(); err != nil {
		return fmt.Errorf("nie udało się zapisać konfiguracji: %v", err)
	}
	return nil
}

// initializeList inicjalizuje nową listę
func initializeList(title string) list.Model {
	l := list.New([]list.Item{}, list.NewDefaultDelegate(), 0, 0)
	l.Title = title
	l.SetShowHelp(true)
	l.SetFilteringEnabled(false)
	return l
}

// UpdateLists aktualizuje listy hostów i haseł
// internal/ui/models.go

// UpdateLists aktualizuje listy hostów i haseł
func (m *Model) UpdateLists() {
	// Pobierz aktualne dane z konfiguracji
	m.hosts = m.config.GetHosts()
	m.passwords = m.config.GetPasswords()

	// Aktualizacja listy hostów
	var hostItems []list.Item
	for _, h := range m.hosts {
		hostItems = append(hostItems, HostItem{host: h})
	}
	m.hostList.SetItems(hostItems)

	// Aktualizacja listy haseł
	var passwordItems []list.Item
	for _, p := range m.passwords {
		passwordItems = append(passwordItems, PasswordItem{password: p})
	}
	m.passwordList.SetItems(passwordItems)
}

// HostItem implementuje list.Item dla hosta
type HostItem struct {
	host models.Host
}

func (i HostItem) Title() string       { return i.host.Name }
func (i HostItem) Description() string { return i.host.Description }
func (i HostItem) FilterValue() string { return i.host.Name }

// PasswordItem implementuje list.Item dla hasła
type PasswordItem struct {
	password models.Password
}

func (i PasswordItem) Title() string       { return i.password.Description }
func (i PasswordItem) Description() string { return "********" }
func (i PasswordItem) FilterValue() string { return i.password.Description }

// SetStatus ustawia status aplikacji
func (m *Model) SetStatus(msg string, isError bool) {
	m.status = Status{
		Message: msg,
		IsError: isError,
	}
}

// ClearStatus czyści status
func (m *Model) ClearStatus() {
	m.status = Status{}
}

func (m *Model) ConnectToHost(host *models.Host, password string) interface{} {
	// Jeśli istnieje poprzednie połączenie, zamknij je
	if m.sshClient != nil {
		m.DisconnectHost()
	}

	// Utwórz nowego klienta SSH
	m.sshClient = ssh.NewSSHClient(m.passwords)

	// Nawiąż połączenie
	err := m.sshClient.Connect(host, password)
	if err != nil {
		return fmt.Errorf("failed to connect: %v", err)
	}

	m.selectedHost = host

	// Utwórz nowy obiekt transferu plików (poprawione wywołanie)
	m.transfer = ssh.NewFileTransfer(m.cipher)

	return nil
}

func (m *Model) DisconnectHost() interface{} {
	if m.transfer != nil {
		if err := m.transfer.Disconnect(); // Używamy Disconnect zamiast Close
		err != nil {
			return fmt.Errorf("error disconnecting transfer: %v", err)
		}
		m.transfer = nil
	}
	if m.sshClient != nil {
		m.sshClient.Disconnect()
		m.sshClient = nil
	}
	m.selectedHost = nil
	return nil
}

// GetSelectedHost zwraca aktualnie wybrany host
func (m *Model) GetSelectedHost() *models.Host {
	return m.selectedHost
}

// SetSelectedHost ustawia wybrany host
func (m *Model) SetSelectedHost(host *models.Host) {
	m.selectedHost = host
}

// IsConnected sprawdza czy jest aktywne połączenie
func (m *Model) IsConnected() bool {
	return m.sshClient != nil && m.sshClient.IsConnected()
}

func (m *Model) GetTransfer() *ssh.FileTransfer {
	if m.transfer == nil {
		m.transfer = ssh.NewFileTransfer(m.cipher)
	}
	return m.transfer
}

// SetActiveView switch view and initialize if needed
func (m *Model) SetActiveView(view View) {
	m.activeView = view
	// Resetujemy komunikaty o błędach
	m.status = Status{}

	// Inicjalizujemy odpowiedni widok
	switch view {
	case ViewConnect:
		if m.sshClient != nil { // Zmiana z connection na sshClient
			m.DisconnectHost() // Używamy istniejącej metody do rozłączenia
		}
	case ViewMain:
		m.UpdateLists() // Odświeżamy listy przy powrocie do głównego widoku
	}
}

// Dodaj te metody w internal/ui/models.go

// AddHost dodaje nowego hosta
func (m *Model) AddHost(host *models.Host) interface{} {
	// Sprawdzenie czy host o takiej nazwie już istnieje
	for _, h := range m.config.GetHosts() {
		if h.Name == host.Name {
			return fmt.Errorf("host o nazwie %s już istnieje", host.Name)
		}
	}

	// Dodaj hosta do konfiguracji
	m.config.AddHost(*host)

	// Zaktualizuj lokalną listę hostów
	m.hosts = m.config.GetHosts()
	return nil
}

// UpdateHost aktualizuje istniejącego hosta
func (m *Model) UpdateHost(oldName string, host *models.Host) interface{} {
	for i, h := range m.hosts {
		if h.Name == oldName {
			m.hosts[i] = *host
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hosta %s", oldName)
}

// AddPassword dodaje nowe hasło

func (m *Model) AddPassword(password *models.Password) interface{} {
	// Sprawdzenie czy hasło o takim opisie już istnieje
	for _, p := range m.config.GetPasswords() {
		if p.Description == password.Description {
			return fmt.Errorf("hasło o opisie %s już istnieje", password.Description)
		}
	}

	// Dodaj hasło do konfiguracji
	m.config.AddPassword(*password)

	// Zapisz konfigurację
	if err := m.config.Save(); err != nil {
		return fmt.Errorf("nie udało się zapisać konfiguracji: %v", err)
	}

	// Aktualizuj lokalną listę haseł
	m.passwords = m.config.GetPasswords()
	return nil
}

// UpdatePassword aktualizuje istniejące hasło
func (m *Model) UpdatePassword(oldDesc string, password *models.Password) interface{} {
	for i, p := range m.passwords {
		if p.Description == oldDesc {
			m.passwords[i] = *password
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hasła %s", oldDesc)
}

// GetHosts zwraca listę hostów
func (m *Model) GetHosts() []models.Host {
	return m.hosts
}

// GetPasswords zwraca listę haseł
func (m *Model) GetPasswords() []models.Password {
	return m.passwords
}

// Dodaj w internal/ui/models.go

// GetPasswordByIndex zwraca hasło o danym indeksie
func (m *Model) GetPasswordByIndex(index int) *models.Password {
	if index >= 0 && index < len(m.passwords) {
		return &m.passwords[index]
	}
	return nil
}

func (m *Model) SetCipher(cipher *crypto.Cipher) {
	m.cipher = cipher
}

func (m *Model) GetCipher() *crypto.Cipher {
	return m.cipher
}

// DeleteHost usuwa hosta
func (m *Model) DeleteHost(name string) interface{} {
	// Najpierw znajdź hosta w konfiguracji
	for i, h := range m.config.GetHosts() {
		if h.Name == name {
			// Usuń z konfiguracji
			if err := m.config.DeleteHost(i); err != nil {
				return fmt.Errorf("nie można usunąć hosta: %v", err)
			}
			// Usuń z lokalnej listy
			for j, host := range m.hosts {
				if host.Name == name {
					m.hosts = append(m.hosts[:j], m.hosts[j+1:]...)
					break
				}
			}
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hosta %s", name)
}

// DeletePassword usuwa hasło
func (m *Model) DeletePassword(description string) interface{} {
	// Najpierw znajdź indeks hasła
	var passwordIndex int = -1
	for i, p := range m.config.GetPasswords() {
		if p.Description == description {
			passwordIndex = i
			break
		}
	}

	if passwordIndex == -1 {
		return fmt.Errorf("nie znaleziono hasła %s", description)
	}

	// Sprawdź czy hasło nie jest używane przez żadnego hosta
	for _, h := range m.config.GetHosts() {
		if h.PasswordID == passwordIndex {
			return fmt.Errorf("hasło jest używane przez hosta %s", h.Name)
		}
	}

	// Usuń hasło z konfiguracji
	if err := m.config.DeletePassword(passwordIndex); err != nil {
		return fmt.Errorf("nie można usunąć hasła: %v", err)
	}

	// Usuń z lokalnej listy
	for i, p := range m.passwords {
		if p.Description == description {
			m.passwords = append(m.passwords[:i], m.passwords[i+1:]...)
			break
		}
	}

	return nil
}

func (m *Model) GetActiveView() View {
	return m.activeView
}

func (m *Model) SetTransfer(transfer *ssh.FileTransfer) {
	m.transfer = transfer
}

func (m *Model) IsQuitting() bool {
	return m.quitting
}

// internal/ui/models.go

func (m *Model) SetQuitting(quitting bool) {
	m.quitting = quitting
}

func (m *Model) SetTerminalSize(width, height int) {
	m.terminalWidth = width
	m.terminalHeight = height
}

func (m *Model) GetTerminalWidth() int {
	return m.terminalWidth
}

func (m *Model) GetTerminalHeight() int {
	return m.terminalHeight
}

func (m *Model) UpdateWindowSize(width, height int) {
	m.terminalWidth = width
	m.terminalHeight = height
}

func (m *Model) ToggleSelection(path string) {
	if m.selectedItems == nil {
		m.selectedItems = make(map[string]bool)
	}
	m.selectedItems[path] = !m.selectedItems[path]
}

func (m *Model) IsSelected(path string) bool {
	if m.selectedItems == nil {
		return false
	}
	return m.selectedItems[path]
}

func (m *Model) ClearSelection() {
	m.selectedItems = make(map[string]bool)
}

func (m *Model) GetSelectedPaths() []string {
	var paths []string
	for path, isSelected := range m.selectedItems {
		if isSelected {
			paths = append(paths, path)
		}
	}
	return paths
}

func (m *Model) HasSelectedItems() bool {
	return len(m.GetSelectedPaths()) > 0
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/models.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/styles.go
package ui

import (
	"github.com/charmbracelet/lipgloss"
)

var (
	// Kolory
	Subtle    = lipgloss.Color("#6C7086") // Subtelny szary dla mniej istotnego tekstu
	Highlight = lipgloss.Color("#7DC4E4") // Jasny niebieski dla tytułów i podświetleń
	Special   = lipgloss.Color("#FF9E64") // Pomarańczowy dla przycisków i elementów specjalnych
	Error     = lipgloss.Color("#F38BA8") // Jasny czerwony dla błędów
	StatusBar = lipgloss.Color("#33B2FF") // Neonowy róż dla paska statusu
	Border    = lipgloss.Color("#33B2FF") // Kolor obramowań

	// Style podstawowe
	BaseStyle = lipgloss.NewStyle().
			Foreground(Subtle).
			BorderStyle(lipgloss.NormalBorder()).
			BorderForeground(Border)

	// Tytuł
	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Highlight).
			MarginLeft(2)

	// Elementy menu
	SelectedItemStyle = lipgloss.NewStyle().
				Foreground(Highlight).
				Bold(true)

	ItemStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF3A99"))

	// Opisy i informacje
	DescriptionStyle = lipgloss.NewStyle().
				Foreground(Subtle).
				MarginLeft(2)

	Infotext = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF3A99"))

	HostStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#2DAFFF"))

	LabelStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#A6ADC8")) // Subtelny szary dla etykiet
	// Pola wejściowe
	InputStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			BorderStyle(lipgloss.NormalBorder()).
			BorderForeground(Highlight).
			Padding(0, 1)
	// Dodatkowe style dla statusów
	StatusConnectingStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#7DC4E4")). // Jasny niebieski jak Highlight
				Bold(true)

	StatusConnectedStyle = lipgloss.NewStyle().
				Foreground(Special). // Pomarańczowy jak dla przycisków
				Bold(true)

	StatusDefaultStyle = lipgloss.NewStyle().
				Foreground(Subtle)

	StatusStyle = lipgloss.NewStyle().
			Foreground(StatusBar)

	// Style dla paneli
	PanelTitleStyle = lipgloss.NewStyle().
			Foreground(Highlight).
			Bold(true).
			Padding(0, 1)

	// Style dla wyłączonych elementów
	ButtonDisabledStyle = lipgloss.NewStyle().
				Foreground(Subtle).
				Bold(true)

	DescriptionDisabledStyle = lipgloss.NewStyle().
					Foreground(Subtle).
					MarginLeft(2)

	// Zmiana nazwy Infotext na InfotextStyle dla spójności
	InfotextStyle = Infotext
	// Przyciski
	ButtonStyle = lipgloss.NewStyle().
			Foreground(Special).
			Bold(true)

	// Statusy
	SuccessStyle = lipgloss.NewStyle().
			Foreground(Special).
			Bold(true)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(Error).
			Bold(true)

	// Kontenery
	WindowStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.DoubleBorder()).
			BorderForeground(Border).
			Padding(1, 2)

	// Tabele
	HeaderStyle = lipgloss.NewStyle().
			Foreground(Highlight).
			Bold(true).
			Underline(true).
			Padding(0, 1)

	CellStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Padding(0, 1)

	// Style dialogów
	DialogStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(Border).
			Padding(1, 2)

	DialogTitleStyle = lipgloss.NewStyle().
				Bold(true).
				Foreground(Highlight).
				Padding(0, 1)

	DialogButtonStyle = lipgloss.NewStyle().
				Foreground(Special).
				Bold(true).
				Padding(0, 2)

	// Panele
	PanelStyle = lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(Border).
			Padding(0, 1)

	// Pasek statusu
	StatusBarStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Background(StatusBar).
			Bold(true).
			Padding(0, 1).
			Width(103)

	// Pasek poleceń
	CommandBarStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Padding(0, 0).
			Width(103).
			BorderStyle(lipgloss.NormalBorder()).
			BorderTop(true).
			BorderForeground(Border)

	// Style dla różnych typów plików
	DirectoryStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#1E90FF")). // DodgerBlue dla katalogów
			Bold(true)

	ExecutableStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#32CD32")) // LimeGreen dla plików wykonywalnych

	ArchiveStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#BA55D3")) // MediumOrchid dla archiwów

	ImageStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF8C00")) // DarkOrange dla obrazów

	DocumentStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFD700")) // Gold dla dokumentów

	CodeCStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#00CED1")) // DarkTurquoise dla plików .c

	CodeHStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#4682B4")) // SteelBlue dla plików .h

	CodeGoStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#2E8B57")) // SeaGreen dla plików .go

	CodePyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6A5ACD")) // SlateBlue dla plików .py

	CodeJsStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#DAA520")) // Goldenrod dla plików .js

	CodeJsonStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#7FFF00")) // Chartreuse dla plików .json

	CodeDefaultStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#708090")) // SlateGray dla pozostałych plików kodu

	DefaultFileStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#A9A9A9")) // DarkGray dla pozostałych plików

	SelectedFileStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#FF00BD")) // DarkGray dla pozostałych plików
)

// GetMaxWidth zwraca maksymalną szerokość tekstu w slice'u
func GetMaxWidth(items []string) int {
	maxWidth := 0
	for _, item := range items {
		if w := lipgloss.Width(item); w > maxWidth {
			maxWidth = w
		}
	}
	return maxWidth
}

// CenterText centruje tekst w danej szerokości
func CenterText(text string, width int) string {
	return lipgloss.PlaceHorizontal(width, lipgloss.Center, text)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/styles.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/edit.go
// internal/ui/views/edit.go

package views

import (
	"fmt"
	"sshManager/internal/models"
	"sshManager/internal/ui"
	"strconv"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type editMode int

const (
	modeNormal editMode = iota
	modeSelectPassword
	modeHostList
	modePasswordList
)

type editView struct {
	model                 *ui.Model
	activeField           int
	editing               bool
	editingHost           bool
	inputs                []textinput.Model
	currentHost           *models.Host
	currentPassword       *models.Password
	errorMsg              string
	mode                  editMode
	passwordList          []models.Password
	selectedPasswordIndex int
	tmpHost               *models.Host
	hosts                 []models.Host
	passwords             []models.Password
	selectedItemIndex     int
	deleteConfirmation    bool
	width                 int // Dodane
	height                int // Dodane
}

func NewEditView(model *ui.Model) *editView {
	v := &editView{
		model:  model,
		inputs: make([]textinput.Model, 6), // Name, Description, Login, IP, Port, Password
		width:  model.GetTerminalWidth(),   // Dodane
		height: model.GetTerminalHeight(),  // Dodane
	}

	// Initialize text inputs
	for i := range v.inputs {
		t := textinput.New()
		t.CharLimit = 64

		switch i {
		case 0:
			t.Placeholder = "Name"
			t.Focus()
		case 1:
			t.Placeholder = "Description"
			t.EchoMode = textinput.EchoNormal // Ensure it's normal text
		case 2:
			t.Placeholder = "Login"
		case 3:
			t.Placeholder = "IP/Host"
		case 4:
			t.Placeholder = "Port"
		case 5:
			t.Placeholder = "Password"
			t.EchoMode = textinput.EchoPassword
		}

		v.inputs[i] = t
	}

	return v
}

func (v *editView) Init() tea.Cmd {
	return textinput.Blink
}

func (v *editView) View() string {
	var content string

	contentWidth := min(v.width-40, 160) // Maksymalna szerokość z marginesami

	switch v.mode {
	case modeHostList:
		content = v.renderHostList(contentWidth)
	case modePasswordList:
		content = v.renderPasswordList(contentWidth)
	case modeSelectPassword:
		content = v.renderPasswordSelection(contentWidth)
	default:
		if v.editing {
			if v.editingHost {
				content = v.renderHostEdit(contentWidth)
			} else {
				content = v.renderPasswordEdit(contentWidth)
			}
		} else {
			content = v.renderMainMenu(contentWidth)
		}
	}

	if v.errorMsg != "" {
		content += "\n" + ui.ErrorStyle.Render(v.errorMsg)
	}

	finalContent := ui.WindowStyle.
		Width(contentWidth).
		Render(content)

	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Center,
		lipgloss.Center,
		finalContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

func (v *editView) renderPasswordSelection(width int) string {
	content := ui.TitleStyle.Render("Select Password for Host") + "\n\n"

	if len(v.passwordList) == 0 {
		content += ui.ErrorStyle.Render("No passwords available. Please add a password first.") + "\n"
	} else {
		listWidth := width - 4 // Margines wewnętrzny
		for i, pwd := range v.passwordList {
			prefix := "  "
			if i == v.selectedPasswordIndex {
				prefix = "> "
				line := fmt.Sprintf("%s%-*s",
					prefix,
					listWidth-len(prefix),
					pwd.Description)
				content += ui.SelectedItemStyle.Render(line) + "\n"
			} else {
				line := fmt.Sprintf("%s%-*s",
					prefix,
					listWidth-len(prefix),
					pwd.Description)
				content += line + "\n"
			}
		}
	}

	content += "\n" + v.renderControls(
		Control{"ENTER", "Select"},
		Control{"ESC", "Cancel"},
	)

	return content
}

func (v *editView) renderHostList(width int) string {
	content := ui.TitleStyle.Render("Host List") + "\n\n"

	if len(v.hosts) == 0 {
		content += ui.DescriptionStyle.Render("No hosts available. Press 'h' to add a new host.") + "\n"
	} else {
		listWidth := width - 4     // Margines wewnętrzny
		nameWidth := listWidth / 2 // Połowa szerokości na nazwę

		for i, host := range v.hosts {
			prefix := "  "
			if i == v.selectedItemIndex {
				prefix = "> "
			}

			// Formatuj linię z nazwą i opisem obok siebie
			line := fmt.Sprintf("%s%-*s %-*s",
				prefix,
				nameWidth,
				host.Name,
				listWidth-nameWidth-len(prefix),
				"("+host.Description+")")

			if i == v.selectedItemIndex {
				content += ui.SelectedItemStyle.Render(line) + "\n"
			} else {
				content += line + "\n"
			}
		}
	}

	content += "\n" + v.renderControls(
		Control{"e", "Edit"},
		Control{"d", "Delete"},
		Control{"ESC", "Back"},
	)

	return content
}

func (v *editView) renderPasswordList(width int) string {
	content := ui.TitleStyle.Render("Password List") + "\n\n"

	if len(v.passwords) == 0 {
		content += ui.DescriptionStyle.Render("No passwords available. Press 'p' to add a new password.") + "\n"
	} else {
		listWidth := width - 4
		for i, pass := range v.passwords {
			prefix := "  "
			if i == v.selectedItemIndex {
				prefix = "> "
				line := fmt.Sprintf("%s%-*s",
					prefix,
					listWidth-len(prefix),
					pass.Description)
				content += ui.SelectedItemStyle.Render(line) + "\n"
			} else {
				line := fmt.Sprintf("%s%-*s",
					prefix,
					listWidth-len(prefix),
					pass.Description)
				content += line + "\n"
			}
		}
	}

	content += "\n" + v.renderControls(
		Control{"e", "Edit"},
		Control{"d", "Delete"},
		Control{"ESC", "Back"},
	)

	return content
}

func (v *editView) renderPasswordEdit(width int) string {
	title := "Add New Password"
	if v.currentPassword != nil {
		title = "Edit Password"
	}

	content := ui.TitleStyle.Render(title) + "\n\n"

	// Zmniejszamy szerokość pola wejściowego, aby pasowało do ramki
	inputWidth := width - 8 // Odjęcie marginesów i ramki

	// Ustawienia dla pól wejściowych
	labels := []string{
		"Description:",
		"Password:",
	}

	for i, input := range v.inputs[:2] {
		content += labels[i] + "\n"
		inputStyle := ui.InputStyle.Width(inputWidth)
		if i == v.activeField {
			inputStyle = ui.SelectedItemStyle.Width(inputWidth)
		}
		content += inputStyle.Render(input.View()) + "\n\n"
	}

	content += v.renderControls(
		Control{"ENTER", "Save"},
		Control{"ESC", "Cancel"},
		Control{"↑/↓", "Navigate"},
	)

	return content
}

func (v *editView) renderHostEdit(width int) string {
	title := "Add New Host"
	if v.currentHost != nil {
		title = "Edit Host"
	}

	content := ui.TitleStyle.Render(title) + "\n\n"

	// Zmniejszamy szerokość pola wejściowego
	inputWidth := width - 8 // Odjęcie marginesów i ramki

	labels := []string{
		"Host Name:",
		"Description:",
		"Login:",
		"IP/Host:",
		"Port:",
	}

	for i, input := range v.inputs[:5] {
		content += labels[i] + "\n"
		inputStyle := ui.InputStyle.Width(inputWidth)
		if i == v.activeField {
			inputStyle = ui.SelectedItemStyle.Width(inputWidth)
		}
		content += inputStyle.Render(input.View()) + "\n\n"
	}

	content += v.renderControls(
		Control{"ENTER", "Save"},
		Control{"ESC", "Cancel"},
		Control{"↑/↓", "Navigate"},
	)

	return content
}

func (v *editView) renderMainMenu(width int) string {
	content := ui.TitleStyle.Render("Edit Mode") + "\n\n"

	menuItems := []struct {
		key, description string
	}{
		{"h", "Add new host"},
		{"H", "Host list"},
		{"p", "Add new password"},
		{"P", "Password list"},
		{"ESC", "Back"},
	}

	menuWidth := width - 4
	for _, item := range menuItems {
		line := fmt.Sprintf("%-*s", menuWidth,
			fmt.Sprintf("%s - %s",
				ui.ButtonStyle.Render(item.key),
				item.description))
		content += line + "\n"
	}

	return content
}

// Helper struct for rendering controls
type Control struct {
	key, description string
}

func (v *editView) renderControls(controls ...Control) string {
	var content string
	for i, ctrl := range controls {
		if i > 0 {
			content += "    "
		}
		content += ui.ButtonStyle.Render(ctrl.key) + " - " + ctrl.description
	}
	return content
}

// internal/ui/views/edit.go - część 3

// internal/ui/views/edit.go

func (v *editView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.width = msg.Width
		v.height = msg.Height
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		return v, nil
	case tea.KeyMsg:
		// Najpierw sprawdzamy czy jesteśmy w trybie wprowadzania tekstu
		if v.editing && v.mode != modeSelectPassword &&
			v.mode != modeHostList && v.mode != modePasswordList {
			// Obsługujemy tylko klawisze specjalne w trybie edycji
			switch msg.String() {
			case "esc":
				return v.handleEscapeKey()
			case "enter":
				return v.handleEnterKey()
			case "tab", "shift+tab", "up", "down":
				return v.handleNavigationKey(msg.String())
			default:
				// Przekazujemy wszystkie inne klawisze do aktywnego pola tekstowego
				v.inputs[v.activeField], cmd = v.inputs[v.activeField].Update(msg)
				return v, cmd
			}
		}

		// Jeśli nie jesteśmy w trybie edycji, obsługujemy wszystkie klawisze normalnie
		switch msg.String() {
		case "esc":
			return v.handleEscapeKey()
		case "tab", "shift+tab", "up", "down":
			return v.handleNavigationKey(msg.String())
		case "enter":
			return v.handleEnterKey()
		case "h", "H", "p", "P":
			return v.handleModeKey(msg.String())
		case "e", "d":
			return v.handleActionKey(msg.String())
		}
	}

	return v, cmd
}

func (v *editView) handleEscapeKey() (tea.Model, tea.Cmd) {
	switch v.mode {
	case modeSelectPassword:
		v.mode = modeNormal
		v.editing = false
		v.resetState()
		return v, nil

	case modeHostList, modePasswordList:
		v.mode = modeNormal
		v.editing = false
		v.resetState()
		return v, nil

	default:
		if !v.editing {
			v.model.SetStatus("", false)
			v.model.SetActiveView(ui.ViewMain)
			v.resetState()
			return v, nil
		}
		v.editing = false
		v.resetState()
		return v, nil
	}
}

func (v *editView) handleNavigationKey(key string) (tea.Model, tea.Cmd) {
	switch v.mode {
	case modeSelectPassword:
		v.navigatePasswordSelection(key)
		return v, nil

	case modeHostList, modePasswordList:
		v.navigateList(key)
		return v, nil

	default:
		if v.editing {
			v.navigateFields(key)
		}
	}

	return v, nil
}

func (v *editView) navigatePasswordSelection(key string) {
	if key == "up" || key == "shift+tab" {
		v.selectedPasswordIndex--
		if v.selectedPasswordIndex < 0 {
			v.selectedPasswordIndex = len(v.passwordList) - 1
		}
	} else {
		v.selectedPasswordIndex++
		if v.selectedPasswordIndex >= len(v.passwordList) {
			v.selectedPasswordIndex = 0
		}
	}
}

func (v *editView) navigateList(key string) {
	maxItems := len(v.hosts)
	if v.mode == modePasswordList {
		maxItems = len(v.passwords)
	}

	if key == "up" || key == "shift+tab" {
		v.selectedItemIndex--
		if v.selectedItemIndex < 0 {
			v.selectedItemIndex = maxItems - 1
		}
	} else {
		v.selectedItemIndex++
		if v.selectedItemIndex >= maxItems {
			v.selectedItemIndex = 0
		}
	}
}

func (v *editView) navigateFields(key string) {
	if key == "up" || key == "shift+tab" {
		v.activeField--
	} else {
		v.activeField++
	}

	maxFields := 5 // For host editing
	if !v.editingHost {
		maxFields = 2 // For password editing
	}

	// Wrap around navigation
	if v.activeField >= maxFields {
		v.activeField = 0
	} else if v.activeField < 0 {
		v.activeField = maxFields - 1
	}

	// Update focus
	for i := range v.inputs {
		if i == v.activeField {
			v.inputs[i].Focus()
		} else {
			v.inputs[i].Blur()
		}
	}
}

func (v *editView) handleModeKey(key string) (tea.Model, tea.Cmd) {
	if v.editing {
		return v, nil
	}

	switch key {
	case "h":
		v.editing = true
		v.editingHost = true
		v.initializeHostInputs()

	case "H":
		v.mode = modeHostList
		v.editing = true
		v.hosts = v.model.GetHosts()
		v.selectedItemIndex = 0
		v.deleteConfirmation = false

	case "p":
		v.editing = true
		v.editingHost = false
		v.initializePasswordInputs()

	case "P":
		v.mode = modePasswordList
		v.editing = true
		v.passwords = v.model.GetPasswords()
		v.selectedItemIndex = 0
		v.deleteConfirmation = false
	}

	return v, nil
}

// internal/ui/views/edit.go - część 4

func (v *editView) handleActionKey(key string) (tea.Model, tea.Cmd) {
	switch v.mode {
	case modeHostList:
		if len(v.hosts) == 0 {
			return v, nil
		}
		return v.handleHostListAction(key)

	case modePasswordList:
		if len(v.passwords) == 0 {
			return v, nil
		}
		return v.handlePasswordListAction(key)
	}
	return v, nil
}

func (v *editView) handleHostListAction(key string) (tea.Model, tea.Cmd) {
	switch key {
	case "e":
		v.currentHost = &v.hosts[v.selectedItemIndex]
		v.editingHost = true
		v.mode = modeNormal
		v.initializeHostInputs()
		return v, nil

	case "d":
		if !v.deleteConfirmation {
			v.errorMsg = "Press 'd' again to confirm deletion"
			v.deleteConfirmation = true
			return v, nil
		}

		host := v.hosts[v.selectedItemIndex]
		if err := v.model.DeleteHost(host.Name); err != nil {
			v.errorMsg = fmt.Sprint(err)
		} else {
			if err := v.model.SaveConfig(); err != nil {
				v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
				return v, nil
			}
			v.model.UpdateLists()
			v.hosts = v.model.GetHosts()
			if v.selectedItemIndex >= len(v.hosts) {
				v.selectedItemIndex = len(v.hosts) - 1
			}
			v.model.SetStatus("Host deleted successfully", false)
		}
		v.deleteConfirmation = false
		return v, nil
	}
	return v, nil
}

func (v *editView) handlePasswordListAction(key string) (tea.Model, tea.Cmd) {
	switch key {
	case "e":
		v.currentPassword = &v.passwords[v.selectedItemIndex]
		v.editingHost = false
		v.mode = modeNormal
		v.initializePasswordInputs()
		return v, nil

	case "d":
		if !v.deleteConfirmation {
			v.errorMsg = "Press 'd' again to confirm deletion"
			v.deleteConfirmation = true
			return v, nil
		}

		password := v.passwords[v.selectedItemIndex]
		if err := v.model.DeletePassword(password.Description); err != nil {
			v.errorMsg = fmt.Sprint(err)
		} else {
			if err := v.model.SaveConfig(); err != nil {
				v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
				return v, nil
			}
			v.model.UpdateLists()
			v.passwords = v.model.GetPasswords()
			if v.selectedItemIndex >= len(v.passwords) {
				v.selectedItemIndex = len(v.passwords) - 1
			}
			v.model.SetStatus("Password deleted successfully", false)
		}
		v.deleteConfirmation = false
		return v, nil
	}
	return v, nil
}

func (v *editView) handleEnterKey() (tea.Model, tea.Cmd) {
	switch {
	case v.mode == modeSelectPassword:
		return v.saveHostWithPassword()

	case v.mode == modeHostList, v.mode == modePasswordList:
		return v, nil

	case !v.editing:
		v.editing = true
		v.editingHost = true
		v.initializeHostInputs()
		return v, nil

	default:
		return v.handleSave()
	}
}

func (v *editView) handleSave() (tea.Model, tea.Cmd) {
	if v.editingHost {
		return v.validateAndSaveHost()
	}
	return v.validateAndSavePassword()
}

func (v *editView) validateAndSaveHost() (tea.Model, tea.Cmd) {
	// Sprawdź poprawność pól
	if err := v.validateHostFields(); err != nil {
		v.errorMsg = err.Error()
		return v, nil
	}

	// Sprawdź dostępne hasła
	passwords := v.model.GetPasswords()
	if len(passwords) == 0 {
		v.errorMsg = "Please add a password first"
		return v, nil
	}

	// Initialize temporary host
	v.tmpHost = &models.Host{
		Name:        v.inputs[0].Value(),
		Description: v.inputs[1].Value(),
		Login:       v.inputs[2].Value(),
		IP:          v.inputs[3].Value(),
		Port:        v.inputs[4].Value(),
	}

	// Switch to password selection mode
	v.mode = modeSelectPassword
	v.passwordList = passwords
	v.selectedPasswordIndex = 0
	return v, nil
}

func (v *editView) validateAndSavePassword() (tea.Model, tea.Cmd) {
	// Walidacja pól hasła
	if err := v.validatePasswordFields(); err != nil {
		v.errorMsg = err.Error()
		return v, nil
	}

	// Create new password with encryption
	password, err := models.NewPassword(v.inputs[0].Value(), v.inputs[1].Value(), v.model.GetCipher())
	if err != nil {
		v.errorMsg = fmt.Sprintf("Failed to create password: %v", err)
		return v, nil
	}

	// Update or add password
	var opErr interface{}
	if v.currentPassword != nil {
		opErr = v.model.UpdatePassword(v.currentPassword.Description, password)
	} else {
		opErr = v.model.AddPassword(password)
	}

	if opErr != nil {
		v.errorMsg = fmt.Sprint(opErr)
		return v, nil
	}

	// Save configuration
	if err := v.model.SaveConfig(); err != nil {
		v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
		return v, nil
	}

	// Update UI state
	v.model.UpdateLists()
	v.model.SetStatus("Password saved successfully", false)
	v.editing = false
	v.resetState()
	return v, nil
}

// internal/ui/views/edit.go - część 5

func (v *editView) saveHostWithPassword() (tea.Model, tea.Cmd) {
	v.tmpHost.PasswordID = v.selectedPasswordIndex

	var err interface{}
	if v.currentHost != nil {
		err = v.model.UpdateHost(v.currentHost.Name, v.tmpHost)
	} else {
		err = v.model.AddHost(v.tmpHost)
	}

	if err != nil {
		v.errorMsg = fmt.Sprint(err)
		return v, nil
	}

	if err := v.model.SaveConfig(); err != nil {
		v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
		return v, nil
	}

	v.mode = modeNormal
	v.model.UpdateLists()
	v.model.SetStatus("Host saved successfully", false)
	v.editing = false
	v.resetState()
	return v, nil
}

func (v *editView) initializeHostInputs() {
	// Reset all inputs first
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Set default values or current host values
	if v.currentHost != nil {
		v.inputs[0].SetValue(v.currentHost.Name)
		v.inputs[1].SetValue(v.currentHost.Description)
		v.inputs[2].SetValue(v.currentHost.Login)
		v.inputs[3].SetValue(v.currentHost.IP)
		v.inputs[4].SetValue(v.currentHost.Port)
	}

	// Configure field properties
	v.inputs[0].Placeholder = "Host name"
	v.inputs[1].Placeholder = "Description"
	v.inputs[1].EchoMode = textinput.EchoNormal
	v.inputs[2].Placeholder = "Username"
	v.inputs[3].Placeholder = "IP address or hostname"
	v.inputs[4].Placeholder = "Port number"

	// Focus the first field
	v.activeField = 0
	v.inputs[0].Focus()
}

func (v *editView) initializePasswordInputs() {
	// Reset all inputs first
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Set default values or current password values
	if v.currentPassword != nil {
		v.inputs[0].SetValue(v.currentPassword.Description)
		// Don't set the password value for security reasons
	}

	// Configure field properties
	v.inputs[0].Placeholder = "Password description"
	v.inputs[1].Placeholder = "Enter password"
	v.inputs[1].EchoMode = textinput.EchoPassword

	// Focus the first field
	v.activeField = 0
	v.inputs[0].Focus()
}

func (v *editView) resetState() {
	// Reset basic state
	v.activeField = 0
	v.errorMsg = ""
	v.currentHost = nil
	v.currentPassword = nil
	v.tmpHost = nil
	v.editing = false
	v.mode = modeNormal
	v.deleteConfirmation = false

	// Reset lists
	v.hosts = nil
	v.passwords = nil
	v.passwordList = nil
	v.selectedItemIndex = 0
	v.selectedPasswordIndex = 0

	// Reset all inputs
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}
}

// Helper function to check if a field contains only digits
func isNumeric(s string) bool {
	num, err := strconv.Atoi(s)
	if err != nil {
		return false
	}
	// Sprawdź czy numer portu jest w prawidłowym zakresie (1-65535)
	return num > 0 && num <= 65535
}

// Helper function to validate host fields
func (v *editView) validateHostFields() error {
	if v.inputs[0].Value() == "" {
		return fmt.Errorf("host name is required")
	}
	if v.inputs[2].Value() == "" {
		return fmt.Errorf("login is required")
	}
	if v.inputs[3].Value() == "" {
		return fmt.Errorf("IP/hostname is required")
	}
	if !isNumeric(v.inputs[4].Value()) {
		return fmt.Errorf("port must be a valid number")
	}
	port, _ := strconv.Atoi(v.inputs[4].Value())
	if port < 1 || port > 65535 {
		return fmt.Errorf("port must be between 1 and 65535")
	}
	return nil
}

// Helper function to validate password fields
func (v *editView) validatePasswordFields() error {
	if v.inputs[0].Value() == "" {
		return fmt.Errorf("password description is required")
	}
	if v.inputs[1].Value() == "" {
		return fmt.Errorf("password value is required")
	}
	if len(v.inputs[1].Value()) < 6 {
		return fmt.Errorf("password must be at least 6 characters long")
	}
	return nil
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/edit.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/initial_prompt.go
package views

import (
	"sshManager/internal/ui"
	"sshManager/internal/ui/messages"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type initialPromptModel struct {
	password      []rune
	configPath    string
	errorMessage  string
	width, height int
}

func NewInitialPromptModel(configPath string) *initialPromptModel {
	return &initialPromptModel{
		password:   []rune{},
		configPath: configPath,
	}
}

func (m *initialPromptModel) Init() tea.Cmd {
	return nil
}

func (m *initialPromptModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		return m, nil

	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyRunes:
			m.password = append(m.password, msg.Runes...)
		case tea.KeyBackspace, tea.KeyDelete:
			if len(m.password) > 0 {
				m.password = m.password[:len(m.password)-1]
			}
		case tea.KeyEnter:
			if len(m.password) == 0 {
				m.errorMessage = "Password cannot be empty"
				return m, nil
			}
			// Najpierw wyczyść ekran, potem wyślij hasło
			return m, tea.Sequence(
				tea.ClearScreen,
				tea.ClearScrollArea,
				func() tea.Msg {
					return tea.WindowSizeMsg{
						Width:  m.width,
						Height: m.height,
					}
				},
				func() tea.Msg {
					return messages.PasswordEnteredMsg(string(m.password))
				},
			)
		case tea.KeyCtrlC:
			return m, tea.Quit
		}
	}
	return m, nil
}
func (m *initialPromptModel) View() string {
	// Definicja stylów
	asciiArtStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#7DC4E4")).
		Bold(true)

	infoStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#A6ADC8")).
		Italic(true)

	promptStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FFFFFF")).
		Bold(true)

	errorStyle := ui.ErrorStyle

	// ASCII Art
	asciiArt := `
         _     __  __                                   
 ___ ___| |__ |  \/  | __ _ _ __   __ _  __ _  ___ _ __ 
/ __/ __| '_ \| |\/| |/ _' | '_ \ / _' |/ _' |/ _ \ '__|
\__ \__ \ | | | |  | | (_| | | | | (_| | (_| |  __/ |   
|___/___/_| |_|_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|   
                                        |___/`

	asciiArtRendered := asciiArtStyle.Render(asciiArt)

	// Informacja o pliku konfiguracyjnym
	configInfo := infoStyle.Render("Using config file: " + m.configPath)

	// Pytanie o hasło
	passwordPrompt := promptStyle.Render("Enter encryption key: ")
	maskedPassword := strings.Repeat("*", len(m.password))

	// Połączenie wszystkich elementów
	content := lipgloss.JoinVertical(
		lipgloss.Center,
		asciiArtRendered,
		"",
		configInfo,
		"",
		passwordPrompt+maskedPassword,
	)

	// Dodanie komunikatu o błędzie, jeśli istnieje
	if m.errorMessage != "" {
		content += "\n" + errorStyle.Render(m.errorMessage)
	}

	// Ramka wokół zawartości
	frameStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#7DC4E4")).
		Padding(1, 2)

	framedContent := frameStyle.Render(content)

	// Wyśrodkowanie zawartości
	finalContent := lipgloss.Place(
		m.width, m.height,
		lipgloss.Center, lipgloss.Center,
		framedContent,
	)

	return finalContent
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/initial_prompt.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/main.go
package views

import (
	"fmt"
	"sshManager/internal/models"
	"sshManager/internal/ui"
	"strings"

	"sshManager/internal/ssh"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type mainView struct {
	model         *ui.Model
	hosts         []models.Host
	selectedIndex int
	currentDir    string
	showHostList  bool
	errMsg        string
	status        string
	connecting    bool
	width         int // Dodane
	height        int // Dodane
}

type connectError string

type connectFinishedMsg struct {
	err error
}

func (e connectError) Error() string {
	return string(e)
}

func NewMainView(model *ui.Model) *mainView {
	return &mainView{
		model:        model,
		showHostList: true,
		hosts:        model.GetHosts(),
		currentDir:   getHomeDir(),
		width:        model.GetTerminalWidth(),  // Dodane
		height:       model.GetTerminalHeight(), // Dodane

	}
}

func (v *mainView) Init() tea.Cmd {
	return tea.Sequence(
		tea.ClearScreen,
		tea.ClearScrollArea,
		tea.EnterAltScreen,
	)
}

func (v *mainView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.width = msg.Width
		v.height = msg.Height
		// Dodajemy aktualizację rozmiaru w głównym modelu
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		return v, nil

	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c":
			v.model.SetQuitting(true)
			return v, tea.Quit

		case "up", "k":
			if len(v.hosts) > 0 && !v.connecting {
				v.selectedIndex--
				if v.selectedIndex < 0 {
					v.selectedIndex = len(v.hosts) - 1
				}
				v.errMsg = ""
			}

		case "down", "j":
			if len(v.hosts) > 0 && !v.connecting {
				v.selectedIndex++
				if v.selectedIndex >= len(v.hosts) {
					v.selectedIndex = 0
				}
				v.errMsg = ""
			}
		case "enter", "c":
			// Jeśli trwa łączenie lub nie ma hostów, ignorujemy
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleConnect()

		case "e":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			host := v.hosts[v.selectedIndex]
			v.model.SetSelectedHost(&host)
			v.model.SetActiveView(ui.ViewEdit)
			// Dodajemy sequence komend
			return v, tea.Sequence(
				tea.ClearScreen,
				func() tea.Msg {
					return tea.WindowSizeMsg{
						Width:  v.width,
						Height: v.height,
					}
				},
			)

		case "t":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleTransfer()
		case "d":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleDelete()

		case "n":
			if !v.connecting {
				v.model.SetActiveView(ui.ViewEdit)
				return v, nil
			}

		case "r":
			if !v.connecting {
				v.hosts = v.model.GetHosts()
				v.errMsg = ""
				if v.selectedIndex >= len(v.hosts) {
					v.selectedIndex = len(v.hosts) - 1
				}
				v.status = "Host list refreshed"
			}
		}

	case connectFinishedMsg:
		v.connecting = false
		v.status = ""
		if msg.err != nil {
			v.errMsg = fmt.Sprintf("SSH connection failed: %v", msg.err)
		} else {
			v.errMsg = ""
		}
		return v, nil

	case connectError:
		v.errMsg = msg.Error()
		v.connecting = false
		v.status = ""
		return v, nil
	}

	return v, nil
}

func (v *mainView) handleConnect() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	v.model.SetSelectedHost(&host)

	passwords := v.model.GetPasswords()
	if host.PasswordID >= len(passwords) {
		v.errMsg = "Invalid password ID"
		return v, nil
	}

	password := passwords[host.PasswordID]
	decryptedPass, err := password.GetDecrypted(v.model.GetCipher())
	if err != nil {
		v.errMsg = fmt.Sprintf("Failed to decrypt password: %v", err)
		return v, nil
	}

	v.connecting = true
	v.status = "Connecting..."

	cmd := ssh.CreateSSHCommand(&host, decryptedPass) // Używamy funkcji z pakietu ssh
	return v, tea.ExecProcess(
		cmd,
		func(err error) tea.Msg {
			return connectFinishedMsg{err: err}
		},
	)
}

func (v *mainView) handleDelete() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	if err := v.model.DeleteHost(host.Name); err != nil {
		v.errMsg = fmt.Sprintf("Failed to delete host: %v", err)
	} else {
		if err := v.model.SaveConfig(); err != nil {
			v.errMsg = fmt.Sprintf("Failed to save configuration: %v", err)
			return v, nil
		}
		v.hosts = v.model.GetHosts()
		if v.selectedIndex >= len(v.hosts) {
			v.selectedIndex = len(v.hosts) - 1
		}
		v.status = "Host deleted successfully"
	}
	return v, nil
}

// W pliku internal/ui/views/main.go
func (v *mainView) handleTransfer() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	v.model.SetSelectedHost(&host)

	passwords := v.model.GetPasswords()
	if host.PasswordID >= len(passwords) {
		v.errMsg = "Invalid password ID"
		return v, nil
	}

	password := passwords[host.PasswordID]
	decryptedPass, err := password.GetDecrypted(v.model.GetCipher())
	if err != nil {
		v.errMsg = fmt.Sprintf("Failed to decrypt password: %v", err)
		return v, nil
	}

	transfer := v.model.GetTransfer()
	if err := transfer.Connect(&host, decryptedPass); err != nil {
		v.errMsg = fmt.Sprintf("Failed to establish SFTP connection: %v", err)
		return v, nil
	}

	v.model.SetActiveView(ui.ViewTransfer)

	// Dodajemy sequence komend
	return v, tea.Sequence(
		tea.ClearScreen,
		func() tea.Msg {
			return tea.WindowSizeMsg{
				Width:  v.width,
				Height: v.height,
			}
		},
	)
}

func (v *mainView) View() string {
	// Przygotuj główną zawartość
	var content strings.Builder
	content.WriteString(ui.TitleStyle.Render("SSH Manager") + "\n\n")

	// Główny layout w stylu MC z dwoma panelami
	leftPanel := v.renderHostPanel()
	rightPanel := v.renderDetailsPanel()

	// Połącz panele horyzontalnie
	mainContent := lipgloss.JoinHorizontal(
		lipgloss.Left,
		leftPanel,
		"  +  ", // separator
		rightPanel,
	)

	content.WriteString(mainContent + "\n\n")

	// Status bar
	statusBar := v.renderStatusBar()
	content.WriteString(statusBar + "\n")

	// Command bar
	cmdBar := v.renderCommandBar()
	content.WriteString(cmdBar)

	// Zastosuj styl ramki do całej zawartości
	framedContent := ui.WindowStyle.Render(content.String())

	// Zawsze używaj wymiarów do wycentrowania
	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Center,
		lipgloss.Center,
		framedContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

func (v *mainView) renderHostPanel() string {
	style := ui.PanelStyle.Width(45)
	title := "Available Hosts"

	var content strings.Builder
	if len(v.hosts) == 0 {
		content.WriteString(ui.DescriptionStyle.Render("\n  No hosts available\n  Press 'n' to add new host"))
	} else {
		for i, host := range v.hosts {
			prefix := "  "
			var line string

			// Renderujemy nazwę hosta z użyciem HostStyle
			hostName := ui.HostStyle.Render(host.Name)

			if i == v.selectedIndex {
				// Ustawiamy prefix dla zaznaczonego hosta
				prefix = ui.SuccessStyle.Render("❯ ")
				// Budujemy linię z użyciem SelectedItemStyle i HostStyle
				line = ui.SelectedItemStyle.Render(
					fmt.Sprintf("\n%s%s", prefix, hostName),
				)
			} else {
				// Budujemy linię dla niezaznaczonego hosta z HostStyle
				line = fmt.Sprintf("\n%s%s", prefix, hostName)
			}
			// Dodajemy linię do zawartości
			content.WriteString(line)
		}
	}

	return style.Render(title + "\n" + content.String())
}

func (v *mainView) renderDetailsPanel() string {
	style := ui.PanelStyle.Width(45)
	title := "Host Details"

	var content strings.Builder
	if len(v.hosts) > 0 {
		host := v.hosts[v.selectedIndex]
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Name:"), ui.Infotext.Render(host.Name)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Description:"), ui.Infotext.Render(host.Description)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Login:"), ui.Infotext.Render(host.Login)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Address:"), ui.Infotext.Render(host.IP)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Port:"), ui.Infotext.Render(host.Port)))
	}

	return style.Render(title + "\n" + content.String())
}

func (v *mainView) renderStatusBar() string {
	var status string
	if v.errMsg != "" {
		status = ui.ErrorStyle.Render(v.errMsg)
	} else if v.status != "" {
		status = ui.SuccessStyle.Render(v.status)
	} else if v.model.IsConnected() {
		if host := v.model.GetSelectedHost(); host != nil {
			status = ui.SuccessStyle.Render(fmt.Sprintf("Connected to: %s", host.Name))
		}
	} else {
		status = ui.DescriptionStyle.Render("No active connection, Press:")
	}

	return ui.StatusBarStyle.Render(status)
}

func (v *mainView) renderCommandBar() string {
	commands := []struct {
		key  string
		desc string
	}{
		{"Enter/c", "Connect"},
		{"t", "File Transfer"},
		{"e", "Edit"},
		{"d", "Delete"},
		{"n", "New Host"},
		{"q", "Quit"},
	}

	var cmdBar strings.Builder
	for i, cmd := range commands {
		if i > 0 {
			cmdBar.WriteString(" ∥")
		}
		// Odwróć kolejność: najpierw opis, potem klawisz
		cmdBar.WriteString(ui.DescriptionStyle.Render(cmd.desc))
		cmdBar.WriteString(" ― ")
		cmdBar.WriteString(ui.ButtonStyle.Render(cmd.key))
	}

	return ui.CommandBarStyle.
		Align(lipgloss.Left).
		Render(cmdBar.String())
}

func (v *mainView) IsQuitting() bool {
	return v.model.IsQuitting()
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/main.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/transfer.go
package views

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"sync"
	"time"

	"sshManager/internal/ssh"
	"sshManager/internal/ui"

	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// Dodaj na początku pliku po importach
func getHomeDir() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "."
	}
	return home
}

// Stałe określające tryby i stany
const (
	localPanelActive  = true
	remotePanelActive = false
	maxVisibleItems   = 20
	headerHeight      = 3
	footerHeight      = 4
)

// FileEntry reprezentuje pojedynczy plik lub katalog
type FileEntry struct {
	name    string
	size    int64
	modTime time.Time
	isDir   bool
	mode    os.FileMode // Dodane pole

}

// Panel reprezentuje panel plików (lokalny lub zdalny)
type Panel struct {
	path          string
	entries       []FileEntry
	selectedIndex int
	scrollOffset  int
	active        bool
}

type transferProgressMsg ssh.TransferProgress

type transferFinishedMsg struct {
	err error
}

// transferView implementuje główny widok transferu plików
type transferView struct {
	model         *ui.Model
	localPanel    Panel
	remotePanel   Panel
	statusMessage string
	errorMessage  string
	connecting    bool
	connected     bool
	transferring  bool
	progress      ssh.TransferProgress
	showHelp      bool
	input         textinput.Model
	mutex         sync.Mutex
	width         int         // Dodane
	height        int         // Dodane
	escPressed    bool        // flaga wskazująca czy ESC został wciśnięty
	escTimeout    *time.Timer // timer do resetowania stanu ESC
	popup         *popup      // nowe pole

}
type connectionStatusMsg struct {
	connected bool
	err       error
}

type promptType int

const (
	promptNone promptType = iota
	promptRename
	promptMkdir
	promptDelete
)

type popup struct {
	promptType promptType
	title      string
	message    string
	input      textinput.Model
	width      int
	height     int
}

func NewTransferView(model *ui.Model) *transferView {
	input := textinput.New()
	input.Placeholder = "Enter command..."
	input.CharLimit = 255

	v := &transferView{
		model: model,
		localPanel: Panel{
			path:   getHomeDir(),
			active: true,
			entries: []FileEntry{
				{name: "..", isDir: true},
			},
		},
		remotePanel: Panel{
			path:   "~/", // Tymczasowa wartość
			active: false,
			entries: []FileEntry{
				{name: "..", isDir: true},
			},
		},
		input:  input,
		width:  model.GetTerminalWidth(),
		height: model.GetTerminalHeight(),
	}

	// Inicjalizujemy panel lokalny
	if err := v.updateLocalPanel(); err != nil {
		v.errorMessage = fmt.Sprintf("Failed to load local directory: %v", err)
		return v
	}

	// Inicjujemy połączenie SFTP w tle
	if v.model.GetSelectedHost() != nil {
		go func() {
			// Attempt to establish connection
			err := v.ensureConnected()
			if err != nil {
				v.model.Program.Send(connectionStatusMsg{
					connected: false,
					err:       err,
				})
				return
			}

			// Pobierz katalog domowy i zaktualizuj ścieżkę
			transfer := v.model.GetTransfer()
			if homeDir, err := transfer.GetRemoteHomeDir(); err == nil {
				v.remotePanel.path = homeDir
			}

			// Update remote panel
			err = v.updateRemotePanel()
			if err != nil {
				v.model.Program.Send(connectionStatusMsg{
					connected: false,
					err:       err,
				})
				return
			}

			// Send success message
			v.model.Program.Send(connectionStatusMsg{
				connected: true,
				err:       nil,
			})
		}()
	}

	return v
}

// updateLocalPanel odświeża zawartość lokalnego panelu
func (v *transferView) updateLocalPanel() error {
	entries, err := v.readLocalDirectory(v.localPanel.path)
	if err != nil {
		return err
	}
	v.localPanel.entries = entries
	return nil
}

func (v *transferView) readLocalDirectory(path string) ([]FileEntry, error) {
	dir, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer dir.Close()

	fileInfos, err := dir.Readdir(-1)
	if err != nil {
		return nil, err
	}

	// Zawsze zaczynamy od ".." do nawigacji w górę
	entries := []FileEntry{{
		name:    "..",
		isDir:   true,
		modTime: time.Now(),
	}}

	for _, fi := range fileInfos {
		// Pomijamy ukryte pliki zaczynające się od "." (opcjonalnie)
		if !strings.HasPrefix(fi.Name(), ".") || fi.Name() == ".." {
			entries = append(entries, FileEntry{
				name:    fi.Name(),
				size:    fi.Size(),
				modTime: fi.ModTime(),
				isDir:   fi.IsDir(),
				mode:    fi.Mode(), // Dodane

			})
		}
	}

	// Sortowanie: najpierw katalogi, potem pliki, alfabetycznie
	sort.Slice(entries[1:], func(i, j int) bool {
		// Przesuwamy indeksy o 1, bo pomijamy ".."
		i, j = i+1, j+1
		if entries[i].isDir != entries[j].isDir {
			return entries[i].isDir
		}
		return strings.ToLower(entries[i].name) < strings.ToLower(entries[j].name)
	})

	return entries, nil
}

func (v *transferView) Init() tea.Cmd {
	if !v.connected && !v.connecting && v.model.GetSelectedHost() != nil {
		v.connecting = true
		return v.sendConnectionUpdate() // Usuń argument program
	}
	return nil
}

func (v *transferView) updateRemotePanel() error {
	if err := v.ensureConnected(); err != nil {
		return err
	}

	entries, err := v.readRemoteDirectory(v.remotePanel.path)
	if err != nil {
		v.setConnected(false) // Oznacz jako rozłączony w przypadku błędu
		return err
	}
	v.remotePanel.entries = entries
	return nil
}

// readRemoteDirectory czyta zawartość zdalnego katalogu
func (v *transferView) readRemoteDirectory(path string) ([]FileEntry, error) {
	if err := v.ensureConnected(); err != nil {
		return nil, err
	}

	transfer := v.model.GetTransfer()
	fileInfos, err := transfer.ListRemoteFiles(path)
	if err != nil {
		v.setConnected(false)
		return nil, fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Zawsze zaczynamy od ".." do nawigacji w górę
	entries := []FileEntry{{
		name:    "..",
		isDir:   true,
		modTime: time.Now(),
	}}

	for _, fi := range fileInfos {
		if !strings.HasPrefix(fi.Name(), ".") || fi.Name() == ".." {
			entries = append(entries, FileEntry{
				name:    fi.Name(),
				size:    fi.Size(),
				modTime: fi.ModTime(),
				isDir:   fi.IsDir(),
				mode:    fi.Mode(), // Dodane
			})
		}
	}

	// Sortowanie: najpierw katalogi, potem pliki, alfabetycznie
	sort.Slice(entries[1:], func(i, j int) bool {
		i, j = i+1, j+1
		if entries[i].isDir != entries[j].isDir {
			return entries[i].isDir
		}
		return strings.ToLower(entries[i].name) < strings.ToLower(entries[j].name)
	})

	return entries, nil
}

// getActivePanel zwraca aktywny panel
func (v *transferView) getActivePanel() *Panel {
	if v.localPanel.active {
		return &v.localPanel
	}
	return &v.remotePanel
}

// getInactivePanel zwraca nieaktywny panel
func (v *transferView) getInactivePanel() *Panel {
	if v.localPanel.active {
		return &v.remotePanel
	}
	return &v.localPanel
}

// switchActivePanel przełącza aktywny panel
func (v *transferView) switchActivePanel() {
	v.localPanel.active = !v.localPanel.active
	v.remotePanel.active = !v.remotePanel.active
}

func (v *transferView) renderPanel(p *Panel) string {
	var content strings.Builder

	// Oblicz szerokość panelu
	panelWidth := (min(v.width-40, 160) - 3) / 2

	// Zastosuj styl panelu z ramką
	var panelContent strings.Builder

	// Formatowanie i skracanie ścieżki
	pathText := formatPath(p.path, min(40, panelWidth-5))

	// Użycie stylów ścieżki
	pathStyle := inactivePathStyle
	if p.active {
		pathStyle = activePathStyle
	}
	panelContent.WriteString(pathStyle.Render(pathText))
	panelContent.WriteString("\n")

	// Renderowanie listy plików
	filesList := v.renderFileList(
		p.entries[p.scrollOffset:min(p.scrollOffset+maxVisibleItems, len(p.entries))],
		p.selectedIndex-p.scrollOffset,
		p.active,
		panelWidth-2,
	)
	panelContent.WriteString(filesList)

	// Informacja o przewijaniu
	if len(p.entries) > maxVisibleItems {
		panelContent.WriteString(fmt.Sprintf("\nShowing %d-%d of %d items",
			p.scrollOffset+1,
			min(p.scrollOffset+maxVisibleItems, len(p.entries)),
			len(p.entries)))
	}

	// Zastosuj styl całego panelu
	content.WriteString(panelStyle.
		Width(panelWidth).
		BorderForeground(ui.Subtle).
		Render(panelContent.String()))

	return content.String()
}

func (v *transferView) View() string {
	var content strings.Builder

	// Tytuł i status połączenia
	titleContent := ui.TitleStyle.Render("File Transfer")
	if v.connected {
		if host := v.model.GetSelectedHost(); host != nil {
			titleContent += ui.SuccessStyle.Render(
				fmt.Sprintf(" - Connected to %s (%s)", host.Name, host.IP),
			)
		}
	} else if host := v.model.GetSelectedHost(); host != nil {
		if v.connecting {
			titleContent += ui.DescriptionStyle.Render(" - Establishing connection...")
		} else {
			titleContent += ui.ErrorStyle.Render(
				fmt.Sprintf(" - Not connected to %s (%s)", host.Name, host.IP),
			)
		}
	}
	content.WriteString(titleContent + "\n\n")

	// Obsługa stanu łączenia
	if v.connecting {
		connectingContent := ui.DescriptionStyle.Render("Establishing SFTP connection...")
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			ui.WindowStyle.Render(connectingContent),
		)
	}

	// Obsługa widoku pomocy
	if v.showHelp {
		helpContent := ui.DescriptionStyle.Render(helpText)
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			ui.WindowStyle.Render(helpContent),
		)
	}

	// Oblicz szerokość paneli na podstawie szerokości ekranu
	totalWidth := min(v.width-40, 160) // Zmniejszamy szerokość o marginesy (20 z każdej strony)
	panelWidth := (totalWidth - 3) / 2 // 3 to szerokość separatora

	// Renderuj panele
	leftPanel := v.renderPanel(&v.localPanel)
	rightPanel := ""

	if !v.connected {
		rightPanel = ui.ErrorStyle.Render("\n  No SFTP Connection\n  Press 'q' to return and connect to a host first.")
	} else {
		rightPanel = v.renderPanel(&v.remotePanel)
	}
	// Wyrównaj panele
	leftLines := strings.Split(leftPanel, "\n")
	rightLines := strings.Split(rightPanel, "\n")
	maxLines := max(len(leftLines), len(rightLines))

	// Wyrównaj liczbe linii w panelach
	for i := len(leftLines); i < maxLines; i++ {
		leftLines = append(leftLines, strings.Repeat(" ", panelWidth))
	}
	for i := len(rightLines); i < maxLines; i++ {
		rightLines = append(rightLines, strings.Repeat(" ", panelWidth))
	}

	// Połącz panele
	for i := 0; i < maxLines; i++ {
		content.WriteString(leftLines[i])
		content.WriteString(" │ ")
		content.WriteString(rightLines[i])
		content.WriteString("\n")
	}

	// Pasek postępu
	if v.transferring {
		content.WriteString("\n")
		progressBar := v.formatProgressBar(totalWidth)
		content.WriteString(ui.DescriptionStyle.Render(progressBar))
	}

	if v.isWaitingForInput() {
		content.WriteString("\n" + v.input.View())
	}

	footer := v.renderFooter()
	content.WriteString("\n")
	content.WriteString(footer)

	// Renderuj całość w oknie i wycentruj
	finalContent := ui.WindowStyle.Render(content.String())

	// Jeśli jest aktywny popup, renderuj go na wierzchu
	if v.popup != nil {
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			finalContent+"\n"+v.renderPopup(),
			lipgloss.WithWhitespaceChars(""),
			lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
		)
	}

	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Center,
		lipgloss.Center,
		finalContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

// Pomocnicza funkcja do określania maksimum
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Pomocnicza funkcja min
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// formatSize formatuje rozmiar pliku
func formatSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB",
		float64(size)/float64(div), "KMGTPE"[exp])
}

// navigatePanel obsługuje nawigację w panelu
func (v *transferView) navigatePanel(p *Panel, direction int) {
	if len(p.entries) == 0 {
		p.selectedIndex = 0
		p.scrollOffset = 0
		return
	}

	newIndex := p.selectedIndex + direction

	if newIndex < 0 {
		newIndex = len(p.entries) - 1
	} else if newIndex >= len(p.entries) {
		newIndex = 0
	}

	p.selectedIndex = newIndex

	// Dostosuj przewijanie
	if p.selectedIndex < p.scrollOffset {
		p.scrollOffset = p.selectedIndex
	} else if p.selectedIndex >= p.scrollOffset+maxVisibleItems {
		p.scrollOffset = p.selectedIndex - maxVisibleItems + 1
	}

	// Upewnij się, że scrollOffset nie jest ujemny
	if p.scrollOffset < 0 {
		p.scrollOffset = 0
	}
}

// enterDirectory wchodzi do wybranego katalogu
func (v *transferView) enterDirectory(p *Panel) error {
	if len(p.entries) == 0 || p.selectedIndex >= len(p.entries) {
		return nil
	}

	entry := p.entries[p.selectedIndex]
	if !entry.isDir {
		return nil
	}

	var newPath string
	if entry.name == ".." {
		// Nawigacja do góry
		newPath = filepath.Dir(p.path)
		// Dla Windows możemy potrzebować dodatkowej obsługi ścieżki głównej
		if runtime.GOOS == "windows" && filepath.Dir(newPath) == newPath {
			newPath = filepath.VolumeName(newPath) + "\\"
		}
	} else {
		newPath = filepath.Join(p.path, entry.name)
	}

	// Zapisz poprzednią ścieżkę
	oldPath := p.path
	p.path = newPath

	// Spróbuj odświeżyć zawartość
	var err error
	if p == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	// W przypadku błędu, przywróć poprzednią ścieżkę
	if err != nil {
		p.path = oldPath
		return err
	}

	// Resetuj wybór i przewijanie
	p.selectedIndex = 0
	p.scrollOffset = 0
	return nil
}

func (v *transferView) hasSelectedItems() bool {
	for _, isSelected := range v.getSelectedItems() {
		if isSelected {
			return true
		}
	}
	return false
}

func (v *transferView) getSelectedItems() map[string]bool {
	selected := make(map[string]bool)
	paths := v.model.GetSelectedPaths() // zakładając, że taka metoda istnieje w Model
	for _, path := range paths {
		selected[path] = true
	}
	return selected
}

func (v *transferView) copyFile() tea.Cmd {
	srcPanel := v.getActivePanel()
	dstPanel := v.getInactivePanel()

	// Zbierz wszystkie zaznaczone pliki i foldery
	var itemsToCopy []struct {
		srcPath string
		dstPath string
		isDir   bool
	}

	// Najpierw sprawdź aktualnie wybrany element, jeśli nie ma zaznaczonych
	if !v.hasSelectedItems() {
		if len(srcPanel.entries) == 0 || srcPanel.selectedIndex >= len(srcPanel.entries) {
			v.handleError(fmt.Errorf("no file selected"))
			return nil
		}
		entry := srcPanel.entries[srcPanel.selectedIndex]
		srcPath := filepath.Join(srcPanel.path, entry.name)
		dstPath := filepath.Join(dstPanel.path, entry.name)
		itemsToCopy = append(itemsToCopy, struct {
			srcPath string
			dstPath string
			isDir   bool
		}{srcPath, dstPath, entry.isDir})
	} else {
		// Dodaj wszystkie zaznaczone elementy
		for path, isSelected := range v.getSelectedItems() {
			if isSelected {
				baseName := filepath.Base(path)
				dstPath := filepath.Join(dstPanel.path, baseName)
				// Sprawdź czy to folder czy plik
				info, err := os.Stat(path)
				if err != nil {
					v.handleError(fmt.Errorf("cannot access %s: %v", path, err))
					continue
				}
				itemsToCopy = append(itemsToCopy, struct {
					srcPath string
					dstPath string
					isDir   bool
				}{path, dstPath, info.IsDir()})
			}
		}
	}

	if len(itemsToCopy) == 0 {
		v.handleError(fmt.Errorf("no items to copy"))
		return nil
	}

	v.mutex.Lock()
	v.transferring = true
	v.statusMessage = "Copying files..."
	v.mutex.Unlock()

	transfer := v.model.GetTransfer()

	// Zwróć komendę rozpoczynającą transfer
	return func() tea.Msg {
		progressChan := make(chan ssh.TransferProgress)
		doneChan := make(chan error, 1)

		// Uruchom transfer w goroutine
		go func() {
			var totalErr error
			for _, item := range itemsToCopy {
				var err error
				if item.isDir {
					if srcPanel == &v.localPanel {
						err = v.copyDirectoryToRemote(item.srcPath, item.dstPath, transfer, progressChan)
					} else {
						err = v.copyDirectoryFromRemote(item.srcPath, item.dstPath, transfer, progressChan)
					}
				} else {
					if srcPanel == &v.localPanel {
						err = transfer.UploadFile(item.srcPath, item.dstPath, progressChan)
					} else {
						err = transfer.DownloadFile(item.srcPath, item.dstPath, progressChan)
					}
				}
				if err != nil {
					totalErr = fmt.Errorf("error copying %s: %v", item.srcPath, err)
					break
				}
			}
			doneChan <- totalErr
			close(progressChan)
		}()

		// Goroutine do czytania postępu i wysyłania wiadomości
		go func() {
			for progress := range progressChan {
				v.model.Program.Send(transferProgressMsg(progress))
			}
			err := <-doneChan
			v.model.Program.Send(transferFinishedMsg{err: err})
			// Wyczyść zaznaczenie po zakończeniu
			v.model.ClearSelection()
		}()

		return nil
	}
}

// Dodaj nowe funkcje do obsługi kopiowania folderów
func (v *transferView) copyDirectoryToRemote(localPath, remotePath string, transfer *ssh.FileTransfer, progressChan chan<- ssh.TransferProgress) error {
	// Utwórz katalog na zdalnym serwerze
	if err := transfer.CreateRemoteDirectory(remotePath); err != nil {
		return fmt.Errorf("failed to create remote directory: %v", err)
	}

	// Przejdź przez wszystkie pliki w lokalnym katalogu
	return filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Oblicz względną ścieżkę
		relPath, err := filepath.Rel(localPath, path)
		if err != nil {
			return err
		}

		// Utwórz pełną ścieżkę zdalną
		remotePathFull := filepath.Join(remotePath, relPath)

		if info.IsDir() {
			// Utwórz katalog na zdalnym serwerze
			return transfer.CreateRemoteDirectory(remotePathFull)
		} else {
			// Prześlij plik
			return transfer.UploadFile(path, remotePathFull, progressChan)
		}
	})
}

func (v *transferView) copyDirectoryFromRemote(remotePath, localPath string, transfer *ssh.FileTransfer, progressChan chan<- ssh.TransferProgress) error {
	// Utwórz lokalny katalog
	if err := os.MkdirAll(localPath, 0755); err != nil {
		return fmt.Errorf("failed to create local directory: %v", err)
	}

	// Pobierz listę plików z katalogu zdalnego
	entries, err := transfer.ListRemoteFiles(remotePath)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Rekurencyjnie kopiuj zawartość
	for _, entry := range entries {
		remoteSrcPath := filepath.Join(remotePath, entry.Name())
		localDstPath := filepath.Join(localPath, entry.Name())

		if entry.IsDir() {
			if err := v.copyDirectoryFromRemote(remoteSrcPath, localDstPath, transfer, progressChan); err != nil {
				return err
			}
		} else {
			if err := transfer.DownloadFile(remoteSrcPath, localDstPath, progressChan); err != nil {
				return err
			}
		}
	}

	return nil
}

// deleteFile usuwa wybrany plik
// deleteFile usuwa wybrany plik lub katalog
func (v *transferView) deleteFile() error {
	panel := v.getActivePanel()
	if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
		return fmt.Errorf("no file selected")
	}

	entry := panel.entries[panel.selectedIndex]
	if entry.name == ".." {
		return fmt.Errorf("cannot delete parent directory reference")
	}

	// Dostosuj komunikat w zależności od typu
	itemType := "file"
	if entry.isDir {
		itemType = "directory"
	}

	// Potwierdź usunięcie z odpowiednim komunikatem
	v.statusMessage = fmt.Sprintf("Delete %s '%s'? (y/n)", itemType, entry.name)

	return nil
}

// executeDelete wykonuje faktyczne usuwanie pliku
func (v *transferView) executeDelete() error {
	panel := v.getActivePanel()
	entry := panel.entries[panel.selectedIndex]
	path := filepath.Join(panel.path, entry.name)

	var err error
	itemType := "file"
	if entry.isDir {
		itemType = "directory"
	}

	if panel == &v.localPanel {
		if entry.isDir {
			err = os.RemoveAll(path)
		} else {
			err = os.Remove(path)
		}
	} else {
		transfer := v.model.GetTransfer()
		if entry.isDir {
			// Rekursywne usuwanie katalogu na zdalnym serwerze
			err = v.removeRemoteDirectory(path, transfer)
		} else {
			err = transfer.RemoveRemoteFile(path)
		}
	}

	if err != nil {
		return fmt.Errorf("failed to delete %s '%s': %v", itemType, entry.name, err)
	}

	// Odśwież panel po usunięciu
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Deleted %s '%s'", itemType, entry.name)
	return nil
}

func (v *transferView) removeRemoteDirectory(path string, transfer *ssh.FileTransfer) error {
	// Pobierz listę plików w katalogu
	entries, err := transfer.ListRemoteFiles(path)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Rekurencyjnie usuń zawartość katalogu
	for _, entry := range entries {
		if entry.Name() == "." || entry.Name() == ".." {
			continue
		}

		fullPath := filepath.Join(path, entry.Name())
		if entry.IsDir() {
			// Rekurencyjnie usuń podkatalog
			if err := v.removeRemoteDirectory(fullPath, transfer); err != nil {
				return err
			}
		} else {
			// Usuń plik
			if err := transfer.RemoveRemoteFile(fullPath); err != nil {
				return err
			}
		}
	}

	// Na końcu usuń sam katalog
	return transfer.RemoveRemoteFile(path)
}

// createDirectory tworzy nowy katalog
func (v *transferView) createDirectory(name string) error {
	if name == "" {
		return fmt.Errorf("directory name cannot be empty")
	}

	// Sprawdź czy nazwa nie zawiera niedozwolonych znaków
	if strings.ContainsAny(name, "/\\") {
		return fmt.Errorf("directory name cannot contain path separators")
	}

	panel := v.getActivePanel()
	path := filepath.Join(panel.path, name)

	var err error
	if panel == &v.localPanel {
		err = os.MkdirAll(path, 0755)
	} else {
		if !v.connected {
			return fmt.Errorf("not connected to remote host")
		}
		transfer := v.model.GetTransfer()
		err = transfer.CreateRemoteDirectory(path)
	}

	if err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Odśwież panel
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Created directory '%s'", name)
	return nil
}

// renameFile zmienia nazwę pliku
func (v *transferView) renameFile(newName string) error {
	if newName == "" {
		return fmt.Errorf("new name cannot be empty")
	}

	panel := v.getActivePanel()
	if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
		return fmt.Errorf("no file selected")
	}

	entry := panel.entries[panel.selectedIndex]
	if entry.name == ".." {
		return fmt.Errorf("cannot rename parent directory reference")
	}

	oldPath := filepath.Join(panel.path, entry.name)
	newPath := filepath.Join(panel.path, newName)

	var err error
	if panel == &v.localPanel {
		err = os.Rename(oldPath, newPath)
	} else {
		transfer := v.model.GetTransfer()
		err = transfer.RenameRemoteFile(oldPath, newPath)
	}

	if err != nil {
		return fmt.Errorf("failed to rename file: %v", err)
	}

	// Odśwież panel
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Renamed %s to %s", entry.name, newName)
	return nil
}

// handleError obsługuje błędy i wyświetla komunikat
func (v *transferView) handleError(err error) {
	if err != nil {
		v.errorMessage = err.Error()
	}
}

func (v *transferView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.mutex.Lock()
		v.width = msg.Width
		v.height = msg.Height
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		v.mutex.Unlock()
		return v, nil

	case transferProgressMsg:
		v.mutex.Lock()
		v.progress = ssh.TransferProgress(msg)
		v.mutex.Unlock()
		return v, nil

	case transferFinishedMsg:
		v.mutex.Lock()
		v.transferring = false
		if msg.err != nil {
			v.errorMessage = fmt.Sprintf("Transfer error: %v", msg.err)
		} else {
			v.statusMessage = "Transfer completed successfully"
			dstPanel := v.getInactivePanel()
			if dstPanel == &v.localPanel {
				v.updateLocalPanel()
			} else {
				v.updateRemotePanel()
			}
		}
		v.mutex.Unlock()
		return v, nil

	case connectionStatusMsg:
		v.mutex.Lock()
		defer v.mutex.Unlock()
		v.connecting = false
		if msg.err != nil {
			v.connected = false
			v.errorMessage = fmt.Sprintf("Connection error: %v", msg.err)
			v.statusMessage = ""
		} else {
			v.connected = msg.connected
			v.statusMessage = "Connection established"
			v.errorMessage = ""
		}
		return v, nil

	case tea.KeyMsg:
		// Najpierw obsłużmy popup jeśli jest aktywny
		if v.popup != nil {
			switch msg.String() {
			case "esc":
				v.popup = nil
				return v, nil
			case "enter":
				if v.popup.promptType != promptDelete {
					if err := v.handleCommand(v.input.Value()); err != nil {
						v.handleError(err)
					}
					v.popup = nil
					return v, nil
				}
			case "y":
				if v.popup.promptType == promptDelete {
					if err := v.executeDelete(); err != nil {
						v.handleError(err)
					}
					v.popup = nil
					return v, nil
				}
			case "n":
				if v.popup.promptType == promptDelete {
					v.popup = nil
					return v, nil
				}
			default:
				if v.popup.promptType != promptDelete {
					var cmd tea.Cmd
					v.input, cmd = v.input.Update(msg)
					return v, cmd
				}
			}
		}
		// Najpierw obsłużmy wyjście z pomocy jeśli jest aktywna
		if v.showHelp {
			switch msg.String() {
			case "esc", "q", "f1":
				v.showHelp = false
				return v, nil
			default:
				return v, nil // Ignoruj inne klawisze w trybie pomocy
			}
		}

		// Obsługa wejścia użytkownika, jeśli czekamy na input
		if v.isWaitingForInput() {
			switch msg.String() {
			case "enter":
				if err := v.handleCommand(v.input.Value()); err != nil {
					v.handleError(err)
				}
				v.input.Reset()
				return v, nil
			case "esc": // Dodajemy obsługę ESC
				// Czyścimy komunikat o oczekiwaniu na input
				v.statusMessage = ""
				// Resetujemy pole input
				v.input.Reset()
				return v, nil
			default:
				var cmd tea.Cmd
				v.input, cmd = v.input.Update(msg)
				return v, cmd
			}
		}
		// Obsługa sekwencji ESC
		if v.escPressed {
			switch msg.String() {
			case "0", "q":
				if v.transferring {
					return v, nil
				}
				if v.connected {
					transfer := v.model.GetTransfer()
					if transfer != nil {
						transfer.Disconnect()
					}
				}
				v.model.SetActiveView(ui.ViewMain)
				return v, nil

			case "5":
				if !v.transferring {
					cmd := v.copyFile()
					v.escPressed = false
					if v.escTimeout != nil {
						v.escTimeout.Stop()
					}
					return v, cmd
				}

			case "6":
				if !v.transferring {
					v.popup = createPopup(promptRename, "Rename", "Enter new name:")
					v.input.SetValue("")
					v.input.Focus()
				}
				return v, nil

			case "7":
				if !v.transferring {
					v.popup = createPopup(promptMkdir, "Create Directory", "Enter directory name:")
					v.input.SetValue("")
					v.input.Focus()
				}
				return v, nil

			case "8":
				if !v.transferring {
					if err := v.deleteFile(); err != nil {
						v.handleError(err)
					}
				}
			}
			// Reset stanu ESC
			v.escPressed = false
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			return v, nil
		}

		// Standardowa obsługa klawiszy
		switch msg.String() {
		case "esc":
			if v.popup != nil {
				v.popup = nil
				return v, nil
			}
			v.escPressed = true
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			v.escTimeout = time.NewTimer(500 * time.Millisecond)
			go func() {
				<-v.escTimeout.C
				v.escPressed = false
			}()
			return v, nil

		case "q":
			if v.transferring {
				return v, nil
			}
			if v.connected {
				transfer := v.model.GetTransfer()
				if transfer != nil {
					transfer.Disconnect()
				}
			}
			v.model.SetActiveView(ui.ViewMain)
			return v, nil

		case "f5", "c":
			if !v.transferring {
				cmd := v.copyFile()
				return v, cmd
			}
			return v, nil

			// W metodzie Update w sekcji obsługi klawiszy
		case "f6", "r":
			if !v.transferring {
				v.popup = createPopup(promptRename, "Rename", "Enter new name:")
				v.input.SetValue("")
				v.input.Focus()
			}
			return v, nil

		case "f7", "m":
			if !v.transferring {
				v.popup = createPopup(promptMkdir, "Create Directory", "Enter directory name:")
				v.input.SetValue("")
				v.input.Focus()
			}
			return v, nil

		case "f8", "d":
			if !v.transferring {
				panel := v.getActivePanel()
				if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
					return v, nil
				}
				entry := panel.entries[panel.selectedIndex]
				if entry.name == ".." {
					return v, nil
				}
				v.popup = createPopup(promptDelete, "Delete", fmt.Sprintf("Delete %s '%s'? (y/n)",
					map[bool]string{true: "directory", false: "file"}[entry.isDir],
					entry.name))
			}
			return v, nil

		case "tab":
			if v.connected {
				v.switchActivePanel()
				v.errorMessage = ""
			}
			return v, nil

		case "up", "k":
			panel := v.getActivePanel()
			v.navigatePanel(panel, -1)
			v.errorMessage = ""
			return v, nil

		case "down", "j":
			panel := v.getActivePanel()
			v.navigatePanel(panel, 1)
			v.errorMessage = ""
			return v, nil

		case "enter":
			panel := v.getActivePanel()
			if err := v.enterDirectory(panel); err != nil {
				v.handleError(err)
			}
			return v, nil

		case "s":
			if !v.transferring {
				panel := v.getActivePanel()
				if len(panel.entries) > 0 && panel.selectedIndex < len(panel.entries) {
					entry := panel.entries[panel.selectedIndex]
					path := filepath.Join(panel.path, entry.name)
					if entry.name != ".." {
						v.model.ToggleSelection(path)
					}
				}
			}
			return v, nil

		case "y":
			if strings.HasPrefix(v.statusMessage, "Delete ") {
				if err := v.executeDelete(); err != nil {
					v.handleError(err)
				}
				v.statusMessage = ""
			}
			return v, nil

		case "n":
			if strings.HasPrefix(v.statusMessage, "Delete ") {
				v.statusMessage = "Delete cancelled"
			}
			return v, nil

		case "f1":
			v.showHelp = !v.showHelp
			return v, nil

		case "ctrl+r":
			if err := v.updateLocalPanel(); err != nil {
				v.handleError(err)
			}
			if v.connected {
				if err := v.updateRemotePanel(); err != nil {
					v.handleError(err)
				}
			}
			return v, nil
		}

	case ssh.TransferProgress:
		v.progress = msg
		return v, nil
	}

	return v, nil
}

// handleCommand obsługuje wprowadzanie komend
func (v *transferView) handleCommand(cmd string) error {
	if v.popup == nil {
		return fmt.Errorf("no active popup")
	}

	switch v.popup.promptType {
	case promptRename:
		err := v.renameFile(cmd)
		v.popup = nil
		return err
	case promptMkdir:
		err := v.createDirectory(cmd)
		v.popup = nil
		return err
	default:
		v.popup = nil
		return fmt.Errorf("unknown command")
	}
}

// internal/ui/views/transfer.go

func (v *transferView) formatProgressBar(width int) string {
	if !v.transferring || v.progress.TotalBytes == 0 {
		return ""
	}

	percentage := float64(v.progress.TransferredBytes) / float64(v.progress.TotalBytes)
	barWidth := width - 30 // Zostaw miejsce na procenty i prędkość
	completedWidth := int(float64(barWidth) * percentage)

	bar := fmt.Sprintf("[%s%s] %3.0f%%",
		strings.Repeat("=", completedWidth),
		strings.Repeat(" ", barWidth-completedWidth),
		percentage*100)

	elapsed := time.Since(v.progress.StartTime).Seconds()
	if elapsed == 0 {
		elapsed = 1 // Zapobieganie dzieleniu przez zero
	}
	speed := float64(v.progress.TransferredBytes) / elapsed

	return fmt.Sprintf("%s %s %s/s",
		v.progress.FileName,
		bar,
		formatSize(int64(speed)))
}

// shouldShowDeleteConfirm sprawdza czy wyświetlić potwierdzenie usunięcia
func (v *transferView) shouldShowDeleteConfirm() bool {
	return strings.HasPrefix(v.statusMessage, "Delete ")
}

// isWaitingForInput sprawdza czy oczekuje na wprowadzenie tekstu
func (v *transferView) isWaitingForInput() bool {
	return strings.HasPrefix(v.statusMessage, "Enter ")
}

var helpText = `
 File Transfer Help
 -----------------
 Tab          - Switch panel
 Enter        - Enter directory
 F5/ESC+5/c   - Copy file
 F6/ESC+6/r   - Rename
 F7/ESC+7/m   - Create directory
 F8/ESC+8/d   - Delete
 F1           - Toggle help
 Ctrl+r       - Refresh
 q/ESC+0      - Exit
 s            - Select/Unselect file

 Navigation
 ----------
 Up/k         - Move up
 Down/j       - Move down
`

func (v *transferView) renderShortcuts() string {
	t := table.New()

	columns := []table.Column{
		{Title: "Switch panel", Width: 12},
		{Title: "Select", Width: 8},
		{Title: "Copy", Width: 14},
		{Title: "Rename", Width: 14},
		{Title: "MkDir", Width: 14},
		{Title: "Delete", Width: 14},
		{Title: "Help", Width: 6},
		{Title: "Exit", Width: 10},
	}
	t.SetColumns(columns)

	rows := []table.Row{
		{
			"[Tab]",
			"[s]",
			"[F5|ESC+5|c]",
			"[F6|ESC+6|r]",
			"[F7|ESC+7|m]",
			"[F8|ESC+8|d]",
			"[F1]",
			"[q|ESC+0]",
		},
	}
	t.SetRows(rows)

	// Ustawiamy style
	s := table.DefaultStyles()
	t.SetStyles(s)

	// Ustawiamy wysokość tabeli na 2 (nagłówek + jeden wiersz)
	t.SetHeight(2)

	return t.View()
}

// Pomocnicze stałe dla kolorów i stylów
var (
	panelBorder = lipgloss.Border{
		Top:         "─",
		Bottom:      "─",
		Left:        "│",
		Right:       "│",
		TopLeft:     "┌",
		TopRight:    "┐",
		BottomLeft:  "└",
		BottomRight: "┘",
	}

	panelStyle = lipgloss.NewStyle().
			Border(panelBorder).
			BorderForeground(ui.Subtle).
			Padding(0, 1).
			Height(20) // Dodaj stałą wysokość

	activePathStyle = lipgloss.NewStyle().
			Bold(true).
			Background(ui.Highlight).
			Foreground(lipgloss.Color("0"))

	inactivePathStyle = lipgloss.NewStyle().
				Foreground(ui.Subtle)
)

// formatPath formatuje ścieżkę do wyświetlenia
func formatPath(path string, maxWidth int) string {
	if len(path) <= maxWidth {
		return path
	}

	// Dodaj "..." na początku jeśli ścieżka jest za długa
	return "..." + path[len(path)-(maxWidth-3):]
}

func getFileType(entry FileEntry) string {
	if entry.isDir {
		return "directory"
	}

	// Określenie typu na podstawie rozszerzenia
	ext := strings.ToLower(filepath.Ext(entry.name))

	// Archiwa
	switch ext {
	case ".zip", ".tar", ".gz", ".bz2", ".xz", ".7z", ".rar":
		return "archive"
	}

	// Obrazy
	switch ext {
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp":
		return "image"
	}

	// Dokumenty
	switch ext {
	case ".txt", ".doc", ".docx", ".pdf", ".md", ".csv", ".xlsx", ".odt":
		return "document"
	}

	// Pliki wykonywalne
	switch ext {
	case ".exe", ".sh", ".bat", ".cmd", ".com", ".app":
		return "executable"
	}

	// Pliki kodu
	switch ext {
	case ".c":
		return "code_c"
	case ".h":
		return "code_h"
	case ".go":
		return "code_go"
	case ".py":
		return "code_py"
	case ".js":
		return "code_js"
	case ".json":
		return "code_json"
		// Możesz dodać więcej rozszerzeń dla innych języków programowania tutaj
	}

	// Jeśli plik ma ustawione prawa wykonywania
	if entry.mode&0111 != 0 {
		return "executable"
	}

	return "default"
}

// internal/ui/views/transfer.go
// internal/ui/views/transfer.go

func (v *transferView) renderFileList(entries []FileEntry, selected int, _ bool, width int) string {
	t := table.New(
		table.WithColumns([]table.Column{
			{Title: " ", Width: 2}, // Kolumna na gwiazdkę
			{Title: "Name", Width: width - 37},
			{Title: "Size", Width: 10},
			{Title: "Modified", Width: 19},
		}),
	)

	var rows []table.Row
	for _, entry := range entries {
		path := filepath.Join(v.getActivePanel().path, entry.name)
		isMarked := v.model.IsSelected(path)

		// Tworzenie wiersza
		prefix := " "
		if isMarked {
			prefix = "*"
		}

		name := entry.name
		if entry.isDir {
			name = "[" + name + "]"
		}

		row := table.Row{
			prefix,
			name,
			formatSize(entry.size),
			entry.modTime.Format("2006-01-02 15:04"),
		}
		rows = append(rows, row)
	}

	t.SetRows(rows)

	// Renderujemy tabelę
	tableOutput := t.View()

	// Teraz dodajemy kolory linijka po linijce
	var coloredOutput strings.Builder
	lines := strings.Split(tableOutput, "\n")

	for i, line := range lines {
		// Pomijamy linie nagłówka (pierwsza linia)
		if i == 0 {
			coloredOutput.WriteString(line + "\n")
			continue
		}

		// Sprawdzamy czy ta linia odpowiada jakiemuś plikowi
		entryIndex := i - 1 // odejmujemy 1 bo pierwsza linia to nagłówek
		if entryIndex >= 0 && entryIndex < len(entries) {
			entry := entries[entryIndex]
			var style lipgloss.Style

			// Specjalne traktowanie linii ".."
			if entry.name == ".." {
				if entryIndex == selected {
					// Ten sam styl dla aktywnego i nieaktywnego panelu gdy ".." jest zaznaczone
					style = lipgloss.NewStyle().
						Bold(true).
						Background(ui.Highlight).
						Foreground(lipgloss.Color("0"))
				} else {
					style = ui.DirectoryStyle
				}
			} else if entryIndex == selected {
				// Ten sam styl dla zaznaczenia w obu panelach
				style = lipgloss.NewStyle().
					Bold(true).
					Background(ui.Highlight).
					Foreground(lipgloss.Color("0"))
			} else if entry.isDir {
				// Katalogi zawsze używają DirectoryStyle
				style = ui.DirectoryStyle
			} else {
				switch getFileType(entry) {
				case "executable":
					style = ui.ExecutableStyle
				case "archive":
					style = ui.ArchiveStyle
				case "image":
					style = ui.ImageStyle
				case "document":
					style = ui.DocumentStyle
				case "code_c":
					style = ui.CodeCStyle
				case "code_h":
					style = ui.CodeHStyle
				case "code_go":
					style = ui.CodeGoStyle
				case "code_py":
					style = ui.CodePyStyle
				case "code_js":
					style = ui.CodeJsStyle
				case "code_json":
					style = ui.CodeJsonStyle
				default:
					if strings.HasPrefix(getFileType(entry), "code_") {
						style = ui.CodeDefaultStyle
					} else {
						style = ui.DefaultFileStyle
					}
				}
			}
			coloredOutput.WriteString(style.Render(line) + "\n")
		} else {
			coloredOutput.WriteString(line + "\n")
		}
	}

	return coloredOutput.String()
}

func (v *transferView) ensureConnected() error {
	transfer := v.model.GetTransfer()
	if transfer == nil {
		return fmt.Errorf("no transfer client available")
	}

	host := v.model.GetSelectedHost()
	if host == nil {
		return fmt.Errorf("no host selected")
	}

	passwords := v.model.GetPasswords()
	if host.PasswordID >= len(passwords) {
		return fmt.Errorf("invalid password ID")
	}
	password := passwords[host.PasswordID]
	decryptedPass, err := password.GetDecrypted(v.model.GetCipher())
	if err != nil {
		return fmt.Errorf("failed to decrypt password: %v", err)
	}

	if err := transfer.Connect(host, decryptedPass); err != nil {
		return fmt.Errorf("failed to establish SFTP connection: %v", err)
	}

	return nil
}

func (v *transferView) setConnected(connected bool) {
	v.mutex.Lock()
	defer v.mutex.Unlock()
	v.connected = connected
}

func (v *transferView) sendConnectionUpdate() tea.Cmd {
	return func() tea.Msg {
		return connectionStatusMsg{
			connected: v.connected,
			err:       nil,
		}
	}
}

func (v *transferView) renderFooter() string {
	var footerContent strings.Builder

	// Komunikat o błędzie
	if v.errorMessage != "" {
		footerContent.WriteString(ui.ErrorStyle.Render("Error: " + v.errorMessage))
		footerContent.WriteString("\n")
	}

	// Status
	if v.statusMessage != "" {
		style := ui.DescriptionStyle
		if v.shouldShowDeleteConfirm() {
			style = ui.ErrorStyle
		} else if v.isWaitingForInput() {
			style = ui.InputStyle
		}
		footerContent.WriteString(style.Render(v.statusMessage))
		footerContent.WriteString("\n")
	}

	// Komunikat o braku połączenia
	if !v.connected && v.errorMessage == "" {
		footerContent.WriteString(ui.ErrorStyle.Render(
			"SFTP connection not established. Press 'q' to return to main menu and connect first."))
		footerContent.WriteString("\n")
	}

	// Skróty klawiszowe
	if v.connected {
		footerContent.WriteString(v.renderShortcuts())
	} else {
		footerContent.WriteString(ui.ButtonStyle.Render("q") + " - Return to main menu")
	}

	return footerContent.String()
}

func createPopup(pType promptType, title string, message string) *popup {
	input := textinput.New()
	input.Placeholder = "Enter value..."
	input.Focus()

	width := 50 // szerokość popupu
	height := 7 // wysokość popupu

	return &popup{
		promptType: pType,
		title:      title,
		message:    message,
		input:      input,
		width:      width,
		height:     height,
	}
}

func (v *transferView) renderPopup() string {
	if v.popup == nil {
		return ""
	}

	// Style dla popupu
	popupStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(ui.Border).
		Padding(1, 2).
		Width(v.popup.width).
		Height(v.popup.height)

	titleStyle := ui.TitleStyle.
		Align(lipgloss.Center).
		Width(v.popup.width - 4)

	// Budowanie zawartości popupu
	var content strings.Builder
	content.WriteString(titleStyle.Render(v.popup.title) + "\n\n")
	content.WriteString(v.popup.message + "\n")

	// Dodaj pole input dla promptów wymagających wprowadzenia tekstu
	if v.popup.promptType != promptDelete {
		content.WriteString(v.input.View())
	}

	// Dodaj informację o klawiszach
	var keys string
	switch v.popup.promptType {
	case promptDelete:
		keys = "y - Confirm, n - Cancel, ESC - Cancel"
	default:
		keys = "Enter - Confirm, ESC - Cancel"
	}
	content.WriteString("\n" + ui.DescriptionStyle.Render(keys))

	// Renderuj popup
	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Center,
		lipgloss.Center,
		popupStyle.Render(content.String()),
	)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui/views/transfer.go

