# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//components/popup.go
package components

import (
	"sshManager/internal/ui"
	"strings"

	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/lipgloss"
)

type PopupType int

const (
	PopupNone PopupType = iota
	PopupRename
	PopupMkdir
	PopupDelete
	PopupHostKey
	PopupMessage
	PopupKeyEdit // Nowy typ

)

type Popup struct {
	Type         PopupType
	Title        string
	Message      string
	Input        textinput.Model
	Width        int
	Height       int
	ScreenWidth  int // Dodane
	ScreenHeight int // Dodane
}

func NewPopup(popupType PopupType, title, message string, width, height, screenWidth, screenHeight int) *Popup {
	input := textinput.New()
	input.Placeholder = "Enter value..."
	input.Focus()

	return &Popup{
		Type:         popupType,
		Title:        title,
		Message:      message,
		Input:        input,
		Width:        width,
		Height:       height,
		ScreenWidth:  screenWidth,
		ScreenHeight: screenHeight,
	}
}

func (p *Popup) Render() string {
	// Style dla popupu
	popupStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(ui.Border).
		Padding(1, 2).
		Width(p.Width).
		Height(p.Height)

	// Style dla tytułu
	titleStyle := ui.TitleStyle.
		Align(lipgloss.Center).
		Width(p.Width - 4)

	// Budowanie zawartości popupu
	var content strings.Builder
	content.WriteString(titleStyle.Render(p.Title) + "\n\n")
	content.WriteString(p.Message + "\n")

	// Dodaj pole input dla promptów wymagających wprowadzenia tekstu
	if p.Type == PopupRename || p.Type == PopupMkdir {
		content.WriteString("\n" + p.Input.View())
	}

	// Dodaj informację o klawiszach
	var keys string
	switch p.Type {
	case PopupDelete, PopupHostKey:
		keys = "y - Yes, n - No"
	case PopupMessage:
		keys = "ESC/ENTER - Close"
	default:
		keys = "ENTER - Confirm, ESC - Cancel"
	}
	content.WriteString("\n" + ui.DescriptionStyle.Render(keys))

	// Renderowanie popupu
	popupContent := popupStyle.Render(content.String())

	// Wyśrodkowanie popupu na ekranie
	return lipgloss.Place(
		p.ScreenWidth,
		p.ScreenHeight,
		lipgloss.Center,
		lipgloss.Center,
		popupContent,
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//components/popup.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//layout.go
// internal/ui/layout.go

package ui

import (
	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/lipgloss"
	ltable "github.com/charmbracelet/lipgloss/table"
)

// BaseLayout zawiera podstawowe wymiary i style dla layoutu
type BaseLayout struct {
	Width         int
	Height        int
	HeaderHeight  int
	FooterHeight  int
	ContentHeight int
}

// NewBaseLayout tworzy nowy podstawowy layout
func NewBaseLayout(width, height int) BaseLayout {
	const (
		headerHeight = 3 // Wysokość nagłówka
		footerHeight = 4 // Wysokość stopki
	)

	return BaseLayout{
		Width:         width,
		Height:        height,
		HeaderHeight:  headerHeight,
		FooterHeight:  footerHeight,
		ContentHeight: height - headerHeight - footerHeight,
	}
}

// MainContainer tworzy główny kontener aplikacji
func (l BaseLayout) MainContainer() lipgloss.Style {
	return lipgloss.NewStyle().
		Width(l.Width).
		Height(l.Height).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(Border)
}

// Header tworzy styl dla nagłówka
func (l BaseLayout) Header() lipgloss.Style {
	return lipgloss.NewStyle().
		Width(l.Width-2). // -2 na ramkę
		Height(l.HeaderHeight).
		Padding(0, 1).
		BorderStyle(lipgloss.NormalBorder()).
		BorderBottom(true).
		BorderForeground(Border)
}

// Footer tworzy styl dla stopki
func (l BaseLayout) Footer() lipgloss.Style {
	return lipgloss.NewStyle().
		Width(l.Width-2). // -2 na ramkę
		Height(l.FooterHeight).
		Padding(0, 1).
		BorderStyle(lipgloss.NormalBorder()).
		BorderTop(true).
		BorderForeground(Border)
}

// ContentArea tworzy styl dla głównej zawartości
func (l BaseLayout) ContentArea() lipgloss.Style {
	return lipgloss.NewStyle().
		Width(l.Width - 2). // -2 na ramkę
		Height(l.ContentHeight)
}

// CreateBubbleTable tworzy tabelę bubble tea z odpowiednimi stylami
func CreateBubbleTable(columns []table.Column, rows []table.Row, width int) table.Model {
	t := table.New(
		table.WithColumns(columns),
		table.WithRows(rows),
		table.WithHeight(15),
		table.WithWidth(width),
	)

	style := table.Styles{
		Header: lipgloss.NewStyle().
			Bold(true).
			Foreground(Highlight).
			Padding(0, 1),
		Selected: lipgloss.NewStyle().
			Foreground(lipgloss.Color("0")).
			Background(Highlight).
			Bold(true).
			Padding(0, 1),
		Cell: lipgloss.NewStyle().
			Padding(0, 1),
	}

	t.SetStyles(style)
	return t
}

// CreateLipglossTable tworzy tabelę lipgloss z odpowiednimi stylami
func CreateLipglossTable(headers []string, rows [][]string) string {
	tableStyle := func(row, col int) lipgloss.Style {
		switch {
		case row == -1: // Nagłówki
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(Highlight).
				Bold(true)
		default:
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(Special)
		}
	}

	return ltable.New().
		Border(lipgloss.NormalBorder()).
		BorderStyle(lipgloss.NewStyle().Foreground(Border)).
		StyleFunc(tableStyle).
		Headers(headers...).
		Rows(rows...).
		Render()
}

// SplitView tworzy styl dla widoku podzielonego (np. dla transfer view)
func (l BaseLayout) SplitView() (left, right lipgloss.Style) {
	panelWidth := (l.Width - 5) / 2 // 5 to szerokość separatora i ramek

	baseStyle := lipgloss.NewStyle().
		Height(l.ContentHeight).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(Border)

	left = baseStyle.Width(panelWidth)
	right = baseStyle.Width(panelWidth)

	return left, right
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//layout.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//messages/messages.go
// internal/ui/messages/messages.go

package messages

type PasswordEnteredMsg string

// Dodajemy nowe typy wiadomości dla obsługi kluczy SSH
type HostKeyVerificationMsg struct {
	IP          string
	Port        string
	Fingerprint string
}

type ApiKeyEnteredMsg struct {
	Key       string
	LocalMode bool
}

type HostKeyResponseMsg bool

type ReloadAppMsg struct{}

type errMsg string

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//messages/messages.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//models.go
// internal/ui/models.go

package ui

import (
	"fmt"
	"os"
	"sshManager/internal/config"
	"sshManager/internal/crypto"
	"sshManager/internal/models"
	"sshManager/internal/ssh"

	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/list"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"golang.org/x/term"
)

// KeyMap definiuje skróty klawiszowe
type KeyMap struct {
	Up       key.Binding
	Down     key.Binding
	Enter    key.Binding
	Back     key.Binding
	Quit     key.Binding
	Edit     key.Binding
	Connect  key.Binding
	Transfer key.Binding
	Refresh  key.Binding
}

// DefaultKeyMap zwraca domyślne ustawienia klawiszy
func DefaultKeyMap() KeyMap {
	return KeyMap{
		Up: key.NewBinding(
			key.WithKeys("up", "k"),
			key.WithHelp("↑/k", "up"),
		),
		Down: key.NewBinding(
			key.WithKeys("down", "j"),
			key.WithHelp("↓/j", "down"),
		),
		Enter: key.NewBinding(
			key.WithKeys("enter"),
			key.WithHelp("enter", "select"),
		),
		Back: key.NewBinding(
			key.WithKeys("esc"),
			key.WithHelp("esc", "back"),
		),
		Quit: key.NewBinding(
			key.WithKeys("q", "ctrl+c"),
			key.WithHelp("q", "quit"),
		),
		Edit: key.NewBinding(
			key.WithKeys("e"),
			key.WithHelp("e", "edit"),
		),
		Connect: key.NewBinding(
			key.WithKeys("c"),
			key.WithHelp("c", "connect"),
		),
		Transfer: key.NewBinding(
			key.WithKeys("t"),
			key.WithHelp("t", "transfer"),
		),
		Refresh: key.NewBinding(
			key.WithKeys("r"),
			key.WithHelp("r", "refresh"),
		),
	}
}

// Status reprezentuje stan aplikacji
type Status struct {
	Message string
	IsError bool
}

type View int

const (
	ViewMain View = iota
	ViewConnect
	ViewEdit
	ViewTransfer
	ViewHostList
	ViewPasswordList
	ViewHostEdit
	ViewPasswordEdit
)

// Model reprezentuje główny model aplikacji
type Model struct {
	keys           KeyMap
	status         Status
	activeView     View
	sshClient      *ssh.SSHClient // tylko dla trybu SSH
	transfer       *ssh.FileTransfer
	hosts          []models.Host
	passwords      []models.Password
	selectedHost   *models.Host
	hostList       list.Model
	passwordList   list.Model
	input          textinput.Model
	width          int
	height         int
	quitting       bool
	config         *config.Manager
	cipher         *crypto.Cipher
	Program        *tea.Program // Zmiana z małej litery na wielką
	terminalWidth  int
	terminalHeight int
	selectedItems  map[string]bool // mapa przechowująca zaznaczone elementy (klucz: ścieżka pliku)
	localMode      bool            // true jeśli pracujemy bez synchronizacji

}

// Init implementuje tea.Model
func (m Model) Init() tea.Cmd {
	return textinput.Blink
}

func (m *Model) SetProgram(p *tea.Program) {
	m.Program = p
}

func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			m.DisconnectHost() // Zamknij połączenie przed wyjściem
			m.quitting = true
			return m, tea.Quit
		case "c":
			if m.activeView == ViewMain {
				m.activeView = ViewHostList
				return m, nil
			}
		case "esc":
			if m.activeView != ViewMain {
				m.activeView = ViewMain
				return m, nil
			}
		}

	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.hostList.SetWidth(msg.Width)
		m.hostList.SetHeight(msg.Height - 4)
		m.passwordList.SetWidth(msg.Width)
		m.passwordList.SetHeight(msg.Height - 4)
	}

	// Aktualizacja aktywnego widoku
	switch m.activeView {
	case ViewHostList:
		newListModel, cmd := m.hostList.Update(msg)
		m.hostList = newListModel
		if item, ok := m.hostList.SelectedItem().(HostItem); ok {
			m.selectedHost = &item.host
		}
		return m, cmd
	case ViewPasswordList:
		newListModel, cmd := m.passwordList.Update(msg)
		m.passwordList = newListModel
		return m, cmd
	}

	return m, cmd
}

// View implementuje tea.Model
func (m Model) View() string {
	if m.quitting {
		return "Do widzenia!\n"
	}

	var view string
	switch m.activeView {
	case ViewHostList:
		view = m.hostList.View()
	case ViewPasswordList:
		view = m.passwordList.View()
	}

	// Dodaj status jeśli istnieje
	if m.status.Message != "" {
		style := SuccessStyle
		if m.status.IsError {
			style = ErrorStyle
		}
		view += "\n" + style.Render(m.status.Message)
	}

	return view
}

func NewModel() *Model {
	// Pobierz aktualny rozmiar terminala
	width, height, _ := term.GetSize(int(os.Stdout.Fd()))

	configPath, err := config.GetDefaultConfigPath()
	if err != nil {
		configPath = config.DefaultConfigFileName
	}

	configManager := config.NewManager(configPath)

	m := Model{
		keys:           DefaultKeyMap(),
		activeView:     ViewMain,
		input:          textinput.New(),
		hostList:       initializeList("Hosty"),
		passwordList:   initializeList("Hasła"),
		config:         configManager,
		terminalWidth:  width,  // Dodane
		terminalHeight: height, // Dodane
		selectedItems:  make(map[string]bool),
	}

	// Wczytaj zapisaną konfigurację
	if err := configManager.Load(); err != nil {
		m.SetStatus(fmt.Sprintf("Warning: %v", err), true)
	}

	// Załaduj dane do modelu
	m.hosts = configManager.GetHosts()
	m.passwords = configManager.GetPasswords()
	m.UpdateLists()
	m.selectedItems = make(map[string]bool)

	return &m // Zwracamy wskaźnik do m
}

func (m *Model) SaveConfig() interface{} {
	if err := m.config.Save(); err != nil {
		return fmt.Errorf("nie udało się zapisać konfiguracji: %v", err)
	}
	return nil
}

// initializeList inicjalizuje nową listę
func initializeList(title string) list.Model {
	l := list.New([]list.Item{}, list.NewDefaultDelegate(), 0, 0)
	l.Title = title
	l.SetShowHelp(true)
	l.SetFilteringEnabled(false)
	return l
}

// UpdateLists aktualizuje listy hostów i haseł
// internal/ui/models.go

// UpdateLists aktualizuje listy hostów i haseł
func (m *Model) UpdateLists() {
	// Pobierz aktualne dane z konfiguracji
	m.hosts = m.config.GetHosts()
	m.passwords = m.config.GetPasswords()

	// Aktualizacja listy hostów
	var hostItems []list.Item
	for _, h := range m.hosts {
		hostItems = append(hostItems, HostItem{host: h})
	}
	m.hostList.SetItems(hostItems)

	// Aktualizacja listy haseł
	var passwordItems []list.Item
	for _, p := range m.passwords {
		passwordItems = append(passwordItems, PasswordItem{password: p})
	}
	m.passwordList.SetItems(passwordItems)
}

// HostItem implementuje list.Item dla hosta
type HostItem struct {
	host models.Host
}

func (i HostItem) Title() string       { return i.host.Name }
func (i HostItem) Description() string { return i.host.Description }
func (i HostItem) FilterValue() string { return i.host.Name }

// PasswordItem implementuje list.Item dla hasła
type PasswordItem struct {
	password models.Password
}

func (i PasswordItem) Title() string       { return i.password.Description }
func (i PasswordItem) Description() string { return "********" }
func (i PasswordItem) FilterValue() string { return i.password.Description }

// SetStatus ustawia status aplikacji
func (m *Model) SetStatus(msg string, isError bool) {
	m.status = Status{
		Message: msg,
		IsError: isError,
	}
}

// ClearStatus czyści status
func (m *Model) ClearStatus() {
	m.status = Status{}
}

func (m *Model) ConnectToHost(host *models.Host, password string) interface{} {
	// Jeśli istnieje poprzednie połączenie, zamknij je
	if m.sshClient != nil {
		m.DisconnectHost()
	}

	// Utwórz nowego klienta SSH
	m.sshClient = ssh.NewSSHClient(m.passwords)

	// Nawiąż połączenie
	err := m.sshClient.Connect(host, password)
	if err != nil {
		return fmt.Errorf("failed to connect: %v", err)
	}

	m.selectedHost = host

	// Utwórz nowy obiekt transferu plików (poprawione wywołanie)
	m.transfer = ssh.NewFileTransfer(m.cipher)

	return nil
}

func (m *Model) DisconnectHost() interface{} {
	if m.transfer != nil {
		if err := m.transfer.Disconnect(); // Używamy Disconnect zamiast Close
		err != nil {
			return fmt.Errorf("error disconnecting transfer: %v", err)
		}
		m.transfer = nil
	}
	if m.sshClient != nil {
		m.sshClient.Disconnect()
		m.sshClient = nil
	}
	m.selectedHost = nil
	return nil
}

// GetSelectedHost zwraca aktualnie wybrany host
func (m *Model) GetSelectedHost() *models.Host {
	return m.selectedHost
}

// SetSelectedHost ustawia wybrany host
func (m *Model) SetSelectedHost(host *models.Host) {
	m.selectedHost = host
}

// IsConnected sprawdza czy jest aktywne połączenie
func (m *Model) IsConnected() bool {
	return m.sshClient != nil && m.sshClient.IsConnected()
}

func (m *Model) GetTransfer() *ssh.FileTransfer {
	if m.transfer == nil {
		m.transfer = ssh.NewFileTransfer(m.cipher)
	}
	return m.transfer
}

// SetActiveView switch view and initialize if needed
func (m *Model) SetActiveView(view View) {
	m.activeView = view
	// Resetujemy komunikaty o błędach
	m.status = Status{}

	// Inicjalizujemy odpowiedni widok
	switch view {
	case ViewConnect:
		if m.sshClient != nil { // Zmiana z connection na sshClient
			m.DisconnectHost() // Używamy istniejącej metody do rozłączenia
		}
	case ViewMain:
		m.UpdateLists() // Odświeżamy listy przy powrocie do głównego widoku
	}
}

// Dodaj te metody w internal/ui/models.go

// AddHost dodaje nowego hosta
func (m *Model) AddHost(host *models.Host) interface{} {
	// Sprawdzenie czy host o takiej nazwie już istnieje
	for _, h := range m.config.GetHosts() {
		if h.Name == host.Name {
			return fmt.Errorf("host o nazwie %s już istnieje", host.Name)
		}
	}

	// Dodaj hosta do konfiguracji
	m.config.AddHost(*host)

	// Zaktualizuj lokalną listę hostów
	m.hosts = m.config.GetHosts()
	return nil
}

// UpdateHost aktualizuje istniejącego hosta
func (m *Model) UpdateHost(oldName string, host *models.Host) interface{} {
	for i, h := range m.hosts {
		if h.Name == oldName {
			m.hosts[i] = *host
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hosta %s", oldName)
}

// AddPassword dodaje nowe hasło
func (m *Model) AddPassword(password *models.Password) error {
	// Sprawdzenie czy hasło o takim opisie już istnieje
	for _, p := range m.config.GetPasswords() {
		if p.Description == password.Description {
			return fmt.Errorf("hasło o opisie %s już istnieje", password.Description)
		}
	}

	// Dodaj hasło do konfiguracji
	m.config.AddPassword(*password)

	// Zapisz konfigurację
	if err := m.config.Save(); err != nil {
		return fmt.Errorf("nie udało się zapisać konfiguracji: %v", err)
	}

	// Aktualizuj lokalną listę haseł
	m.passwords = m.config.GetPasswords()
	return nil
}

// UpdatePassword aktualizuje istniejące hasło
func (m *Model) UpdatePassword(oldDesc string, password *models.Password) error {
	for i, p := range m.passwords {
		if p.Description == oldDesc {
			m.passwords[i] = *password
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hasła %s", oldDesc)
}

// GetHosts zwraca listę hostów
func (m *Model) GetHosts() []models.Host {
	return m.hosts
}

// GetPasswords zwraca listę haseł
func (m *Model) GetPasswords() []models.Password {
	return m.passwords
}

// Dodaj w internal/ui/models.go

// GetPasswordByIndex zwraca hasło o danym indeksie
func (m *Model) GetPasswordByIndex(index int) *models.Password {
	if index >= 0 && index < len(m.passwords) {
		return &m.passwords[index]
	}
	return nil
}

func (m *Model) SetCipher(cipher *crypto.Cipher) {
	m.cipher = cipher
}

func (m *Model) GetCipher() *crypto.Cipher {
	return m.cipher
}

// DeleteHost usuwa hosta
func (m *Model) DeleteHost(name string) interface{} {
	// Najpierw znajdź hosta w konfiguracji
	for i, h := range m.config.GetHosts() {
		if h.Name == name {
			// Usuń z konfiguracji
			if err := m.config.DeleteHost(i); err != nil {
				return fmt.Errorf("nie można usunąć hosta: %v", err)
			}
			// Usuń z lokalnej listy
			for j, host := range m.hosts {
				if host.Name == name {
					m.hosts = append(m.hosts[:j], m.hosts[j+1:]...)
					break
				}
			}
			return nil
		}
	}
	return fmt.Errorf("nie znaleziono hosta %s", name)
}

// DeletePassword usuwa hasło
func (m *Model) DeletePassword(description string) interface{} {
	// Najpierw znajdź indeks hasła
	var passwordIndex int = -1
	for i, p := range m.config.GetPasswords() {
		if p.Description == description {
			passwordIndex = i
			break
		}
	}

	if passwordIndex == -1 {
		return fmt.Errorf("nie znaleziono hasła %s", description)
	}

	// Sprawdź czy hasło nie jest używane przez żadnego hosta
	for _, h := range m.config.GetHosts() {
		if h.PasswordID == passwordIndex {
			return fmt.Errorf("hasło jest używane przez hosta %s", h.Name)
		}
	}

	// Usuń hasło z konfiguracji
	if err := m.config.DeletePassword(passwordIndex); err != nil {
		return fmt.Errorf("nie można usunąć hasła: %v", err)
	}

	// Usuń z lokalnej listy
	for i, p := range m.passwords {
		if p.Description == description {
			m.passwords = append(m.passwords[:i], m.passwords[i+1:]...)
			break
		}
	}

	return nil
}

func (m *Model) GetActiveView() View {
	return m.activeView
}

func (m *Model) SetTransfer(transfer *ssh.FileTransfer) {
	m.transfer = transfer
}

func (m *Model) IsQuitting() bool {
	return m.quitting
}

// internal/ui/models.go

func (m *Model) SetQuitting(quitting bool) {
	m.quitting = quitting
}

func (m *Model) SetTerminalSize(width, height int) {
	m.terminalWidth = width
	m.terminalHeight = height
}

func (m *Model) GetTerminalWidth() int {
	return m.terminalWidth
}

func (m *Model) GetTerminalHeight() int {
	return m.terminalHeight
}

func (m *Model) UpdateWindowSize(width, height int) {
	m.terminalWidth = width
	m.terminalHeight = height
}

func (m *Model) ToggleSelection(path string) {
	if m.selectedItems == nil {
		m.selectedItems = make(map[string]bool)
	}
	m.selectedItems[path] = !m.selectedItems[path]
}

func (m *Model) IsSelected(path string) bool {
	if m.selectedItems == nil {
		return false
	}
	return m.selectedItems[path]
}

func (m *Model) ClearSelection() {
	m.selectedItems = make(map[string]bool)
}

func (m *Model) GetSelectedPaths() []string {
	var paths []string
	for path, isSelected := range m.selectedItems {
		if isSelected {
			paths = append(paths, path)
		}
	}
	return paths
}

func (m *Model) HasSelectedItems() bool {
	return len(m.GetSelectedPaths()) > 0
}

// AddKey dodaje nowy klucz
func (m *Model) AddKey(key *models.Key) error {
	if err := m.config.AddKey(*key); err != nil {
		return err
	}
	return nil
}

// UpdateKey aktualizuje istniejący klucz
func (m *Model) UpdateKey(oldDesc string, key *models.Key) error {
	// Znajdź indeks klucza o podanym opisie
	keyIndex := -1
	for i, k := range m.config.GetKeys() {
		if k.Description == oldDesc {
			keyIndex = i
			break
		}
	}

	if keyIndex == -1 {
		return fmt.Errorf("key with description '%s' not found", oldDesc)
	}

	if err := m.config.UpdateKey(keyIndex, *key); err != nil {
		return err
	}
	return nil
}

// GetKeys zwraca listę kluczy
func (m *Model) GetKeys() []models.Key {
	return m.config.GetKeys()
}

// DeleteKey usuwa klucz o podanym opisie
func (m *Model) DeleteKey(description string) error {
	if description == "" {
		return fmt.Errorf("key description cannot be empty")
	}

	// Znajdź klucz po opisie
	keyIndex := -1
	keys := m.config.GetKeys()
	for i, k := range keys {
		if k.Description == description {
			keyIndex = i
			break
		}
	}

	if keyIndex == -1 {
		return fmt.Errorf("key '%s' not found", description)
	}

	// Deleguj usuwanie do config.Manager
	if err := m.config.DeleteKey(keyIndex); err != nil {
		return fmt.Errorf("failed to delete key '%s': %v", description, err)
	}

	return nil
}
func (m *Model) SetLocalMode(local bool) {
	m.localMode = local
}

func (m *Model) IsLocalMode() bool {
	return m.localMode
}

func (m *Model) GetConfig() *config.Manager {
	return m.config
}

func (m *Model) SetSSHClient(client *ssh.SSHClient) {
	m.sshClient = client
}

func (m *Model) GetSSHClient() *ssh.SSHClient {
	return m.sshClient
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//models.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//styles.go
package ui

import (
	"github.com/charmbracelet/lipgloss"
)

var (
	// Kolory
	Subtle    = lipgloss.Color("#6C7086")
	Highlight = lipgloss.Color("#7DC4E4")
	Special   = lipgloss.Color("#FF9E64")
	Error     = lipgloss.Color("#F38BA8")
	StatusBar = lipgloss.Color("#E7E7E7")
	Border    = lipgloss.Color("#33B2FF")
	// Style podstawowe
	BaseStyle = lipgloss.NewStyle().
			Foreground(Subtle).
			BorderStyle(lipgloss.NormalBorder()).
			BorderForeground(Border)

	// Tytuł
	TitleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(Highlight).
			MarginLeft(2)

	// Elementy menu
	SelectedItemStyle = lipgloss.NewStyle().
				Foreground(Highlight).
				Bold(true)

	ItemStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF3A99"))

	// Opisy i informacje
	DescriptionStyle = lipgloss.NewStyle().
				Foreground(Subtle).
				MarginLeft(2)

	Infotext = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF3A99"))

	HostStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#2DAFFF"))

	LabelStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#A6ADC8"))

	InputStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			BorderStyle(lipgloss.NormalBorder()).
			BorderForeground(Highlight).
			Padding(0, 1)

	StatusConnectingStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#7DC4E4")).
				Bold(true)

	StatusConnectedStyle = lipgloss.NewStyle().
				Foreground(Special).
				Bold(true)

	StatusDefaultStyle = lipgloss.NewStyle().
				Foreground(Subtle)

	StatusStyle = lipgloss.NewStyle().
			Foreground(StatusBar)

	// Style dla paneli
	PanelTitleStyle = lipgloss.NewStyle().
			Foreground(Highlight).
			Bold(true).
			Padding(0, 1)

	// Style dla wyłączonych elementów
	ButtonDisabledStyle = lipgloss.NewStyle().
				Foreground(Subtle).
				Bold(true)

	DescriptionDisabledStyle = lipgloss.NewStyle().
					Foreground(Subtle).
					MarginLeft(2)

	// Zmiana nazwy Infotext na InfotextStyle dla spójności
	InfotextStyle = Infotext
	// Przyciski
	ButtonStyle = lipgloss.NewStyle().
			Foreground(Special).
			Bold(true)

	// Statusy
	SuccessStyle = lipgloss.NewStyle().
			Foreground(Special).
			Bold(true)

	ErrorStyle = lipgloss.NewStyle().
			Foreground(Error).
			Bold(true)

	// Kontenery
	WindowStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.DoubleBorder()).
			BorderForeground(Border).
			Padding(1, 2)

	// Tabele
	HeaderStyle = lipgloss.NewStyle().
			Foreground(Highlight).
			Bold(true).
			Underline(true).
			Padding(0, 1)

	CellStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Padding(0, 1)

	// Style dialogów
	DialogStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(Border).
			Padding(1, 2)

	DialogTitleStyle = lipgloss.NewStyle().
				Bold(true).
				Foreground(Highlight).
				Padding(0, 1)

	DialogButtonStyle = lipgloss.NewStyle().
				Foreground(Special).
				Bold(true).
				Padding(0, 2)

	// Panele
	PanelStyle = lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(Border).
			Padding(0, 1)

	// Pasek statusu
	StatusBarStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Background(StatusBar).
			Bold(true).
			Padding(0, 1).
			Width(103)

	// Pasek poleceń
	CommandBarStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFFFFF")).
			Padding(0, 0).
			Width(103).
			BorderStyle(lipgloss.NormalBorder()).
			BorderTop(true).
			BorderForeground(Border)

	// Style dla różnych typów plików
	DirectoryStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#1E90FF")).
			Bold(true)

	ExecutableStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#32CD32"))

	ArchiveStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#BA55D3"))

	ImageStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FF8C00"))

	DocumentStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#FFD700"))

	CodeCStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#00CED1"))

	CodeHStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#4682B4"))

	CodeGoStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#2E8B57"))

	CodePyStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6A5ACD"))

	CodeJsStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#DAA520"))
	CodeJsonStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("#7FFF00"))
	CodeDefaultStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#708090"))

	DefaultFileStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#A9A9A9"))
	SelectedFileStyle = lipgloss.NewStyle().
				Foreground(lipgloss.Color("#FF1493"))
)

// GetMaxWidth zwraca maksymalną szerokość tekstu w slice'u
func GetMaxWidth(items []string) int {
	maxWidth := 0
	for _, item := range items {
		if w := lipgloss.Width(item); w > maxWidth {
			maxWidth = w
		}
	}
	return maxWidth
}

// CenterText centruje tekst w danej szerokości
func CenterText(text string, width int) string {
	return lipgloss.PlaceHorizontal(width, lipgloss.Center, text)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//styles.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//themes.go
package ui

import "github.com/charmbracelet/lipgloss"

type Theme struct {
	// Podstawowe kolory
	Subtle    lipgloss.Color
	Highlight lipgloss.Color
	Special   lipgloss.Color
	Error     lipgloss.Color
	StatusBar lipgloss.Color
	Border    lipgloss.Color

	// Kolory elementów menu i informacji
	ItemColor     lipgloss.Color
	InfotextColor lipgloss.Color
	HostColor     lipgloss.Color
	LabelColor    lipgloss.Color
	InputColor    lipgloss.Color

	// Kolory dla typów plików
	DirectoryColor    lipgloss.Color
	ExecutableColor   lipgloss.Color
	ArchiveColor      lipgloss.Color
	ImageColor        lipgloss.Color
	DocumentColor     lipgloss.Color
	DefaultFileColor  lipgloss.Color
	SelectedFileColor lipgloss.Color

	// Kolory dla plików kodu
	CodeCColor       lipgloss.Color
	CodeHColor       lipgloss.Color
	CodeGoColor      lipgloss.Color
	CodePyColor      lipgloss.Color
	CodeJsColor      lipgloss.Color
	CodeJsonColor    lipgloss.Color
	CodeDefaultColor lipgloss.Color
}

var (
	currentThemeIndex = 0

	themes = []Theme{
		{
			// Domyślny motyw (obecny)
			Subtle:    lipgloss.Color("#6C7086"),
			Highlight: lipgloss.Color("#7DC4E4"),
			Special:   lipgloss.Color("#FF9E64"),
			Error:     lipgloss.Color("#F38BA8"),
			StatusBar: lipgloss.Color("#E7E7E7"),
			Border:    lipgloss.Color("#33B2FF"),

			ItemColor:     lipgloss.Color("#FF3A99"),
			InfotextColor: lipgloss.Color("#FF3A99"),
			HostColor:     lipgloss.Color("#2DAFFF"),
			LabelColor:    lipgloss.Color("#A6ADC8"),
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#1E90FF"),
			ExecutableColor:   lipgloss.Color("#32CD32"),
			ArchiveColor:      lipgloss.Color("#BA55D3"),
			ImageColor:        lipgloss.Color("#FF8C00"),
			DocumentColor:     lipgloss.Color("#FFD700"),
			DefaultFileColor:  lipgloss.Color("#A9A9A9"),
			SelectedFileColor: lipgloss.Color("#FF1493"),

			CodeCColor:       lipgloss.Color("#00CED1"),
			CodeHColor:       lipgloss.Color("#4682B4"),
			CodeGoColor:      lipgloss.Color("#2E8B57"),
			CodePyColor:      lipgloss.Color("#6A5ACD"),
			CodeJsColor:      lipgloss.Color("#DAA520"),
			CodeJsonColor:    lipgloss.Color("#7FFF00"),
			CodeDefaultColor: lipgloss.Color("#708090"),
		},
		{
			// Dracula Classic - motyw inspirowany klasycznym schematem kolorów Dracula
			Subtle:    lipgloss.Color("#6272A4"), // Delikatny fioletowy
			Highlight: lipgloss.Color("#8BE9FD"), // Jasny cyan
			Special:   lipgloss.Color("#FF79C6"), // Różowy
			Error:     lipgloss.Color("#FF5555"), // Czerwony
			StatusBar: lipgloss.Color("#44475A"), // Ciemny szary z fioletowym odcieniem
			Border:    lipgloss.Color("#BD93F9"), // Jasny fioletowy

			ItemColor:     lipgloss.Color("#50FA7B"), // Zielony
			InfotextColor: lipgloss.Color("#F1FA8C"), // Żółty
			HostColor:     lipgloss.Color("#8BE9FD"), // Jasny cyan
			LabelColor:    lipgloss.Color("#F8F8F2"), // Jasny szary
			InputColor:    lipgloss.Color("#F8F8F2"), // Jasny szary

			DirectoryColor:    lipgloss.Color("#BD93F9"), // Jasny fioletowy
			ExecutableColor:   lipgloss.Color("#50FA7B"), // Zielony
			ArchiveColor:      lipgloss.Color("#FFB86C"), // Pomarańczowy
			ImageColor:        lipgloss.Color("#FF79C6"), // Różowy
			DocumentColor:     lipgloss.Color("#F1FA8C"), // Żółty
			DefaultFileColor:  lipgloss.Color("#F8F8F2"), // Jasny szary
			SelectedFileColor: lipgloss.Color("#6272A4"), // Delikatny fioletowy

			CodeCColor:       lipgloss.Color("#8BE9FD"), // Jasny cyan
			CodeHColor:       lipgloss.Color("#BD93F9"), // Jasny fioletowy
			CodeGoColor:      lipgloss.Color("#50FA7B"), // Zielony
			CodePyColor:      lipgloss.Color("#FF79C6"), // Różowy
			CodeJsColor:      lipgloss.Color("#F1FA8C"), // Żółty
			CodeJsonColor:    lipgloss.Color("#FFB86C"), // Pomarańczowy
			CodeDefaultColor: lipgloss.Color("#F8F8F2"), // Jasny szary
		},
		{
			// Dracula Night - motyw z ciemniejszymi odcieniami inspirowanymi Dracula Theme
			Subtle:    lipgloss.Color("#44475A"), // Ciemny szary z fioletowym odcieniem
			Highlight: lipgloss.Color("#BD93F9"), // Jasny fioletowy
			Special:   lipgloss.Color("#FFB86C"), // Pomarańczowy
			Error:     lipgloss.Color("#FF5555"), // Czerwony
			StatusBar: lipgloss.Color("#282A36"), // Bardzo ciemny szary
			Border:    lipgloss.Color("#50FA7B"), // Zielony

			ItemColor:     lipgloss.Color("#FF79C6"), // Różowy
			InfotextColor: lipgloss.Color("#8BE9FD"), // Jasny cyan
			HostColor:     lipgloss.Color("#BD93F9"), // Jasny fioletowy
			LabelColor:    lipgloss.Color("#F8F8F2"), // Jasny szary
			InputColor:    lipgloss.Color("#F8F8F2"), // Jasny szary

			DirectoryColor:    lipgloss.Color("#50FA7B"), // Zielony
			ExecutableColor:   lipgloss.Color("#FFB86C"), // Pomarańczowy
			ArchiveColor:      lipgloss.Color("#FF79C6"), // Różowy
			ImageColor:        lipgloss.Color("#8BE9FD"), // Jasny cyan
			DocumentColor:     lipgloss.Color("#F1FA8C"), // Żółty
			DefaultFileColor:  lipgloss.Color("#F8F8F2"), // Jasny szary
			SelectedFileColor: lipgloss.Color("#44475A"), // Ciemny szary z fioletowym odcieniem

			CodeCColor:       lipgloss.Color("#BD93F9"), // Jasny fioletowy
			CodeHColor:       lipgloss.Color("#50FA7B"), // Zielony
			CodeGoColor:      lipgloss.Color("#FFB86C"), // Pomarańczowy
			CodePyColor:      lipgloss.Color("#FF79C6"), // Różowy
			CodeJsColor:      lipgloss.Color("#F1FA8C"), // Żółty
			CodeJsonColor:    lipgloss.Color("#8BE9FD"), // Jasny cyan
			CodeDefaultColor: lipgloss.Color("#F8F8F2"), // Jasny szary
		},
		{
			// VSCodeDark - inspirowany domyślnym motywem VS Code Dark+
			Subtle:    lipgloss.Color("#808080"), // Szary z VS Code
			Highlight: lipgloss.Color("#569CD6"), // Niebieski VS Code
			Special:   lipgloss.Color("#4EC9B0"), // Turkusowy VS Code
			Error:     lipgloss.Color("#F44747"), // Czerwony VS Code
			StatusBar: lipgloss.Color("#007ACC"), // Niebieski statusbar VS Code
			Border:    lipgloss.Color("#569CD6"), // Niebieski VS Code

			ItemColor:     lipgloss.Color("#CE9178"), // Pomarańczowy VS Code
			InfotextColor: lipgloss.Color("#9CDCFE"), // Jasnoniebieski VS Code
			HostColor:     lipgloss.Color("#569CD6"), // Niebieski VS Code
			LabelColor:    lipgloss.Color("#D4D4D4"), // Podstawowy tekst VS Code
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#569CD6"), // Niebieski
			ExecutableColor:   lipgloss.Color("#4EC9B0"), // Turkusowy
			ArchiveColor:      lipgloss.Color("#CE9178"), // Pomarańczowy
			ImageColor:        lipgloss.Color("#C586C0"), // Różowy
			DocumentColor:     lipgloss.Color("#DCDCAA"), // Żółtawy
			DefaultFileColor:  lipgloss.Color("#D4D4D4"), // Podstawowy tekst
			SelectedFileColor: lipgloss.Color("#9CDCFE"), // Jasnoniebieski

			CodeCColor:       lipgloss.Color("#4EC9B0"), // Turkusowy
			CodeHColor:       lipgloss.Color("#569CD6"), // Niebieski
			CodeGoColor:      lipgloss.Color("#4EC9B0"), // Turkusowy
			CodePyColor:      lipgloss.Color("#C586C0"), // Różowy
			CodeJsColor:      lipgloss.Color("#DCDCAA"), // Żółtawy
			CodeJsonColor:    lipgloss.Color("#CE9178"), // Pomarańczowy
			CodeDefaultColor: lipgloss.Color("#D4D4D4"), // Podstawowy tekst
		},
		{
			// DraculaClassic - dokładnie bazujący na palecie Dracula
			Subtle:    lipgloss.Color("#6272a4"), // Comment
			Highlight: lipgloss.Color("#8be9fd"), // Cyan
			Special:   lipgloss.Color("#50fa7b"), // Green
			Error:     lipgloss.Color("#ff5555"), // Red
			StatusBar: lipgloss.Color("#282a36"), // Background
			Border:    lipgloss.Color("#bd93f9"), // Purple

			ItemColor:     lipgloss.Color("#ff79c6"), // Pink
			InfotextColor: lipgloss.Color("#8be9fd"), // Cyan
			HostColor:     lipgloss.Color("#bd93f9"), // Purple
			LabelColor:    lipgloss.Color("#f8f8f2"), // Foreground
			InputColor:    lipgloss.Color("#f8f8f2"), // Foreground

			DirectoryColor:    lipgloss.Color("#8be9fd"), // Cyan
			ExecutableColor:   lipgloss.Color("#50fa7b"), // Green
			ArchiveColor:      lipgloss.Color("#ffb86c"), // Orange
			ImageColor:        lipgloss.Color("#ff79c6"), // Pink
			DocumentColor:     lipgloss.Color("#f1fa8c"), // Yellow
			DefaultFileColor:  lipgloss.Color("#f8f8f2"), // Foreground
			SelectedFileColor: lipgloss.Color("#bd93f9"), // Purple

			CodeCColor:       lipgloss.Color("#50fa7b"), // Green
			CodeHColor:       lipgloss.Color("#8be9fd"), // Cyan
			CodeGoColor:      lipgloss.Color("#50fa7b"), // Green
			CodePyColor:      lipgloss.Color("#ff79c6"), // Pink
			CodeJsColor:      lipgloss.Color("#ffb86c"), // Orange
			CodeJsonColor:    lipgloss.Color("#f1fa8c"), // Yellow
			CodeDefaultColor: lipgloss.Color("#f8f8f2"), // Foreground
		},
		{
			// Molokai - inspirowany klasyczną paletą Molokai
			Subtle:    lipgloss.Color("#808080"), // Szary
			Highlight: lipgloss.Color("#66D9EF"), // Jasnoniebieski molokai
			Special:   lipgloss.Color("#A6E22E"), // Limonkowy molokai
			Error:     lipgloss.Color("#F92672"), // Różowo-czerwony molokai
			StatusBar: lipgloss.Color("#272822"), // Tło molokai
			Border:    lipgloss.Color("#66D9EF"), // Jasnoniebieski molokai

			ItemColor:     lipgloss.Color("#F92672"), // Różowo-czerwony
			InfotextColor: lipgloss.Color("#66D9EF"), // Jasnoniebieski
			HostColor:     lipgloss.Color("#FD971F"), // Pomarańczowy molokai
			LabelColor:    lipgloss.Color("#F8F8F2"), // Jasny tekst molokai
			InputColor:    lipgloss.Color("#F8F8F2"), // Jasny tekst

			DirectoryColor:    lipgloss.Color("#66D9EF"), // Jasnoniebieski
			ExecutableColor:   lipgloss.Color("#A6E22E"), // Limonkowy
			ArchiveColor:      lipgloss.Color("#FD971F"), // Pomarańczowy
			ImageColor:        lipgloss.Color("#AE81FF"), // Fioletowy molokai
			DocumentColor:     lipgloss.Color("#E6DB74"), // Żółty molokai
			DefaultFileColor:  lipgloss.Color("#F8F8F2"), // Jasny tekst
			SelectedFileColor: lipgloss.Color("#F92672"), // Różowo-czerwony

			CodeCColor:       lipgloss.Color("#A6E22E"), // Limonkowy
			CodeHColor:       lipgloss.Color("#66D9EF"), // Jasnoniebieski
			CodeGoColor:      lipgloss.Color("#A6E22E"), // Limonkowy
			CodePyColor:      lipgloss.Color("#AE81FF"), // Fioletowy
			CodeJsColor:      lipgloss.Color("#FD971F"), // Pomarańczowy
			CodeJsonColor:    lipgloss.Color("#E6DB74"), // Żółty
			CodeDefaultColor: lipgloss.Color("#F8F8F2"), // Jasny tekst
		},
		{
			// CyberNeon - inspirowany cyberpunkiem z neonowymi akcentami
			Subtle:    lipgloss.Color("#8B9BB4"), // Jaśniejszy niebieskoszary
			Highlight: lipgloss.Color("#FF2A6D"), // Neonowy różowy
			Special:   lipgloss.Color("#05FFA1"), // Jaskrawy cybernetyczny zielony
			Error:     lipgloss.Color("#FF3366"), // Intensywny czerwony
			StatusBar: lipgloss.Color("#2D3246"), // Ciemny niebieskoszary
			Border:    lipgloss.Color("#FF2A6D"), // Neonowy różowy

			ItemColor:     lipgloss.Color("#FF2A6D"), // Neonowy różowy
			InfotextColor: lipgloss.Color("#05FFA1"), // Cybernetyczny zielony
			HostColor:     lipgloss.Color("#00F1F1"), // Jasny cyjan
			LabelColor:    lipgloss.Color("#C8D3F5"), // Jasny niebieski
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#00F1F1"), // Jasny cyjan
			ExecutableColor:   lipgloss.Color("#05FFA1"), // Cybernetyczny zielony
			ArchiveColor:      lipgloss.Color("#FF9E64"), // Neonowy pomarańczowy
			ImageColor:        lipgloss.Color("#FF2A6D"), // Neonowy różowy
			DocumentColor:     lipgloss.Color("#C792EA"), // Jasny fiolet
			DefaultFileColor:  lipgloss.Color("#8B9BB4"), // Jaśniejszy niebieskoszary
			SelectedFileColor: lipgloss.Color("#00F1F1"), // Jasny cyjan

			CodeCColor:       lipgloss.Color("#05FFA1"),
			CodeHColor:       lipgloss.Color("#00F1F1"),
			CodeGoColor:      lipgloss.Color("#1AEBFF"),
			CodePyColor:      lipgloss.Color("#C792EA"),
			CodeJsColor:      lipgloss.Color("#FFB86C"),
			CodeJsonColor:    lipgloss.Color("#FF9E64"),
			CodeDefaultColor: lipgloss.Color("#8B9BB4"),
		},
		{
			// AtomicDark - inspirowany edytorem Atom i nowoczesnym UI
			Subtle:    lipgloss.Color("#ABB2BF"), // Jasny szary
			Highlight: lipgloss.Color("#61AFEF"), // Jasny niebieski
			Special:   lipgloss.Color("#98C379"), // Zielony atom
			Error:     lipgloss.Color("#E06C75"), // Czerwony atom
			StatusBar: lipgloss.Color("#282C34"), // Ciemny tło
			Border:    lipgloss.Color("#61AFEF"), // Jasny niebieski

			ItemColor:     lipgloss.Color("#C678DD"), // Fioletowy
			InfotextColor: lipgloss.Color("#56B6C2"), // Cyjan
			HostColor:     lipgloss.Color("#61AFEF"), // Jasny niebieski
			LabelColor:    lipgloss.Color("#E5E5E5"), // Bardzo jasny szary
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#61AFEF"), // Jasny niebieski
			ExecutableColor:   lipgloss.Color("#98C379"), // Zielony
			ArchiveColor:      lipgloss.Color("#D19A66"), // Pomarańczowy
			ImageColor:        lipgloss.Color("#C678DD"), // Fioletowy
			DocumentColor:     lipgloss.Color("#56B6C2"), // Cyjan
			DefaultFileColor:  lipgloss.Color("#ABB2BF"), // Jasny szary
			SelectedFileColor: lipgloss.Color("#E5C07B"), // Żółty

			CodeCColor:       lipgloss.Color("#98C379"),
			CodeHColor:       lipgloss.Color("#61AFEF"),
			CodeGoColor:      lipgloss.Color("#56B6C2"),
			CodePyColor:      lipgloss.Color("#C678DD"),
			CodeJsColor:      lipgloss.Color("#E5C07B"),
			CodeJsonColor:    lipgloss.Color("#D19A66"),
			CodeDefaultColor: lipgloss.Color("#ABB2BF"),
		},
		{
			// DraculaPro - inspirowany popularnym motywem Dracula
			Subtle:    lipgloss.Color("#BFBFBF"), // Jasny szary
			Highlight: lipgloss.Color("#BD93F9"), // Fioletowy dracula
			Special:   lipgloss.Color("#50FA7B"), // Zielony dracula
			Error:     lipgloss.Color("#FF5555"), // Czerwony dracula
			StatusBar: lipgloss.Color("#282A36"), // Tło dracula
			Border:    lipgloss.Color("#BD93F9"), // Fioletowy dracula

			ItemColor:     lipgloss.Color("#FF79C6"), // Różowy dracula
			InfotextColor: lipgloss.Color("#8BE9FD"), // Cyjan dracula
			HostColor:     lipgloss.Color("#BD93F9"), // Fioletowy dracula
			LabelColor:    lipgloss.Color("#F8F8F2"), // Biały dracula
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#8BE9FD"), // Cyjan
			ExecutableColor:   lipgloss.Color("#50FA7B"), // Zielony
			ArchiveColor:      lipgloss.Color("#FFB86C"), // Pomarańczowy
			ImageColor:        lipgloss.Color("#FF79C6"), // Różowy
			DocumentColor:     lipgloss.Color("#BD93F9"), // Fioletowy
			DefaultFileColor:  lipgloss.Color("#BFBFBF"), // Jasny szary
			SelectedFileColor: lipgloss.Color("#F1FA8C"), // Żółty

			CodeCColor:       lipgloss.Color("#50FA7B"),
			CodeHColor:       lipgloss.Color("#8BE9FD"),
			CodeGoColor:      lipgloss.Color("#BD93F9"),
			CodePyColor:      lipgloss.Color("#FF79C6"),
			CodeJsColor:      lipgloss.Color("#FFB86C"),
			CodeJsonColor:    lipgloss.Color("#F1FA8C"),
			CodeDefaultColor: lipgloss.Color("#BFBFBF"),
		},
		{
			// Ciemny motyw
			Subtle:    lipgloss.Color("#515671"),
			Highlight: lipgloss.Color("#89DCEB"),
			Special:   lipgloss.Color("#FAB387"),
			Error:     lipgloss.Color("#F38BA8"),
			StatusBar: lipgloss.Color("#C6C9CE"),
			Border:    lipgloss.Color("#89B4FA"),

			ItemColor:     lipgloss.Color("#FF85B5"),
			InfotextColor: lipgloss.Color("#FF85B5"),
			HostColor:     lipgloss.Color("#74C7EC"),
			LabelColor:    lipgloss.Color("#BAC2DE"),
			InputColor:    lipgloss.Color("#CDD6F4"),

			DirectoryColor:    lipgloss.Color("#89B4FA"),
			ExecutableColor:   lipgloss.Color("#A6E3A1"),
			ArchiveColor:      lipgloss.Color("#CBA6F7"),
			ImageColor:        lipgloss.Color("#FAB387"),
			DocumentColor:     lipgloss.Color("#F9E2AF"),
			DefaultFileColor:  lipgloss.Color("#A6ADC8"),
			SelectedFileColor: lipgloss.Color("#F5C2E7"),

			CodeCColor:       lipgloss.Color("#94E2D5"),
			CodeHColor:       lipgloss.Color("#89B4FA"),
			CodeGoColor:      lipgloss.Color("#A6E3A1"),
			CodePyColor:      lipgloss.Color("#CBA6F7"),
			CodeJsColor:      lipgloss.Color("#F9E2AF"),
			CodeJsonColor:    lipgloss.Color("#A6E3A1"),
			CodeDefaultColor: lipgloss.Color("#9399B2"),
		},
		{
			// Aurora - motyw inspirowany zorzą polarną
			Subtle:    lipgloss.Color("#6272A4"), // Delikatny szaro-niebieski
			Highlight: lipgloss.Color("#61AFEF"), // Jasny niebieski
			Special:   lipgloss.Color("#FF79C6"), // Intensywny różowy
			Error:     lipgloss.Color("#FF5555"), // Jasny czerwony
			StatusBar: lipgloss.Color("#282C34"), // Ciemny szaro-niebieski
			Border:    lipgloss.Color("#61AFEF"), // Nowoczesny niebieski

			ItemColor:     lipgloss.Color("#FF79C6"), // Intensywny różowy
			InfotextColor: lipgloss.Color("#FF79C6"), // Intensywny różowy
			HostColor:     lipgloss.Color("#61AFEF"), // Jasny niebieski
			LabelColor:    lipgloss.Color("#FFFFFF"), // Biały tekst
			InputColor:    lipgloss.Color("#FFFFFF"), // Biały tekst

			DirectoryColor:    lipgloss.Color("#61AFEF"), // Jasny niebieski
			ExecutableColor:   lipgloss.Color("#98C379"), // Zielony
			ArchiveColor:      lipgloss.Color("#FFA500"), // Jasny pomarańczowy
			ImageColor:        lipgloss.Color("#61AFEF"), // Jasny niebieski
			DocumentColor:     lipgloss.Color("#98C379"), // Zielony
			DefaultFileColor:  lipgloss.Color("#FFFFFF"), // Biały tekst
			SelectedFileColor: lipgloss.Color("#FF79C6"), // Intensywny różowy

			CodeCColor:       lipgloss.Color("#61AFEF"), // Jasny niebieski
			CodeHColor:       lipgloss.Color("#FF79C6"), // Intensywny różowy
			CodeGoColor:      lipgloss.Color("#98C379"), // Zielony
			CodePyColor:      lipgloss.Color("#FF79C6"), // Intensywny różowy
			CodeJsColor:      lipgloss.Color("#61AFEF"), // Jasny niebieski
			CodeJsonColor:    lipgloss.Color("#61AFEF"), // Jasny niebieski
			CodeDefaultColor: lipgloss.Color("#FFFFFF"), // Biały tekst
		},
		{
			// Cyberpunk - motyw inspirowany futurystycznymi neonami
			Subtle:    lipgloss.Color("#2F2B6D"),
			Highlight: lipgloss.Color("#FF00FF"), // Neonowy fiolet
			Special:   lipgloss.Color("#00FFFF"), // Cyan
			Error:     lipgloss.Color("#FF1493"), // Deep Pink
			StatusBar: lipgloss.Color("#3A3A5A"), // Jasniejszy ciemny fiolet dla lepszej widoczności
			Border:    lipgloss.Color("#FF00FF"),

			ItemColor:     lipgloss.Color("#FF00FF"),
			InfotextColor: lipgloss.Color("#FF00FF"),
			HostColor:     lipgloss.Color("#00FFFF"),
			LabelColor:    lipgloss.Color("#FFFFFF"), // Biały tekst dla lepszej czytelności
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#00FFFF"),
			ExecutableColor:   lipgloss.Color("#39FF14"), // Neonowy zielony
			ArchiveColor:      lipgloss.Color("#FF4500"), // Neonowy pomarańcz
			ImageColor:        lipgloss.Color("#00FFFF"),
			DocumentColor:     lipgloss.Color("#39FF14"),
			DefaultFileColor:  lipgloss.Color("#FFFFFF"),
			SelectedFileColor: lipgloss.Color("#FF00FF"),

			CodeCColor:       lipgloss.Color("#FF00FF"),
			CodeHColor:       lipgloss.Color("#00FFFF"),
			CodeGoColor:      lipgloss.Color("#39FF14"),
			CodePyColor:      lipgloss.Color("#FF00FF"),
			CodeJsColor:      lipgloss.Color("#00FFFF"),
			CodeJsonColor:    lipgloss.Color("#00FFFF"),
			CodeDefaultColor: lipgloss.Color("#FFFFFF"),
		},
		{
			// NeonGreen - motyw z dominującym intensywnym zielonym
			Subtle:    lipgloss.Color("#CCCCCC"), // Jaśniejszy dla lepszej widoczności
			Highlight: lipgloss.Color("#39FF14"), // Neonowy zielony
			Special:   lipgloss.Color("#00FF7F"), // Spring Green
			Error:     lipgloss.Color("#FF4500"), // Neonowy pomarańcz
			StatusBar: lipgloss.Color("#4D4D4D"),
			Border:    lipgloss.Color("#39FF14"),

			ItemColor:     lipgloss.Color("#39FF14"),
			InfotextColor: lipgloss.Color("#39FF14"),
			HostColor:     lipgloss.Color("#00FF7F"),
			LabelColor:    lipgloss.Color("#E0E0E0"), // Jaśniejszy dla lepszej czytelności
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#00FF7F"),
			ExecutableColor:   lipgloss.Color("#7CFC00"),
			ArchiveColor:      lipgloss.Color("#FFD700"),
			ImageColor:        lipgloss.Color("#00FFFF"), // Zmienione na cyan dla lepszego wyróżnienia
			DocumentColor:     lipgloss.Color("#7CFC00"),
			DefaultFileColor:  lipgloss.Color("#E0E0E0"), // Jaśniejszy
			SelectedFileColor: lipgloss.Color("#39FF14"),

			CodeCColor:       lipgloss.Color("#39FF14"),
			CodeHColor:       lipgloss.Color("#00FF7F"),
			CodeGoColor:      lipgloss.Color("#7CFC00"),
			CodePyColor:      lipgloss.Color("#39FF14"),
			CodeJsColor:      lipgloss.Color("#FFD700"), // Zmienione na złoty dla lepszego kontrastu
			CodeJsonColor:    lipgloss.Color("#00FF7F"),
			CodeDefaultColor: lipgloss.Color("#E0E0E0"), // Jaśniejszy
		},
		{
			// RetroOrange - motyw z ciepłym, retro pomarańczowym akcentem
			Subtle:    lipgloss.Color("#D0D0D0"), // Znacznie jaśniejszy dla lepszej widoczności
			Highlight: lipgloss.Color("#FFA500"), // Pomarańczowy
			Special:   lipgloss.Color("#FF8C00"), // Dark Orange
			Error:     lipgloss.Color("#DC143C"), // Crimson
			StatusBar: lipgloss.Color("#444444"),
			Border:    lipgloss.Color("#FFA500"),

			ItemColor:     lipgloss.Color("#FFA500"),
			InfotextColor: lipgloss.Color("#FFA500"),
			HostColor:     lipgloss.Color("#FF8C00"),
			LabelColor:    lipgloss.Color("#E8E8E8"), // Jaśniejszy dla lepszej czytelności
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#FF8C00"),
			ExecutableColor:   lipgloss.Color("#98FB98"), // Jaśniejszy zielony
			ArchiveColor:      lipgloss.Color("#FFD700"),
			ImageColor:        lipgloss.Color("#FF69B4"), // Hot Pink dla lepszego wyróżnienia
			DocumentColor:     lipgloss.Color("#98FB98"), // Jaśniejszy zielony
			DefaultFileColor:  lipgloss.Color("#E8E8E8"), // Jaśniejszy
			SelectedFileColor: lipgloss.Color("#FFA500"),

			CodeCColor:       lipgloss.Color("#FFA500"),
			CodeHColor:       lipgloss.Color("#FF8C00"),
			CodeGoColor:      lipgloss.Color("#98FB98"), // Jaśniejszy zielony
			CodePyColor:      lipgloss.Color("#FFA500"),
			CodeJsColor:      lipgloss.Color("#FFD700"), // Złoty dla lepszego kontrastu
			CodeJsonColor:    lipgloss.Color("#FF8C00"),
			CodeDefaultColor: lipgloss.Color("#E8E8E8"), // Jaśniejszy
		},
		{
			// ElectricBlue - motyw z wyrazistym elektrycznym niebieskim
			Subtle:    lipgloss.Color("#C8C8C8"), // Jaśniejszy dla lepszej widoczności
			Highlight: lipgloss.Color("#00FFFF"), // Electric Blue
			Special:   lipgloss.Color("#1E90FF"), // Dodger Blue
			Error:     lipgloss.Color("#FF6347"), // Tomato
			StatusBar: lipgloss.Color("#333333"),
			Border:    lipgloss.Color("#00FFFF"),

			ItemColor:     lipgloss.Color("#00FFFF"),
			InfotextColor: lipgloss.Color("#00FFFF"),
			HostColor:     lipgloss.Color("#1E90FF"),
			LabelColor:    lipgloss.Color("#E8E8E8"), // Jaśniejszy dla lepszej czytelności
			InputColor:    lipgloss.Color("#FFFFFF"),

			DirectoryColor:    lipgloss.Color("#1E90FF"),
			ExecutableColor:   lipgloss.Color("#90EE90"), // Jaśniejszy zielony
			ArchiveColor:      lipgloss.Color("#FFA07A"), // Light Salmon
			ImageColor:        lipgloss.Color("#FF69B4"), // Hot Pink
			DocumentColor:     lipgloss.Color("#90EE90"), // Jaśniejszy zielony
			DefaultFileColor:  lipgloss.Color("#E8E8E8"), // Jaśniejszy
			SelectedFileColor: lipgloss.Color("#00FFFF"),

			CodeCColor:       lipgloss.Color("#00FFFF"),
			CodeHColor:       lipgloss.Color("#1E90FF"),
			CodeGoColor:      lipgloss.Color("#90EE90"), // Jaśniejszy zielony
			CodePyColor:      lipgloss.Color("#00FFFF"),
			CodeJsColor:      lipgloss.Color("#FFA07A"), // Light Salmon dla kontrastu
			CodeJsonColor:    lipgloss.Color("#1E90FF"),
			CodeDefaultColor: lipgloss.Color("#E8E8E8"), // Jaśniejszy
		},
	}
)

// SwitchTheme przełącza na następny motyw i aktualizuje wszystkie style
func SwitchTheme() {
	currentThemeIndex = (currentThemeIndex + 1) % len(themes)
	currentTheme := themes[currentThemeIndex]
	updateStyles(currentTheme)
}

func updateStyles(theme Theme) {
	// Aktualizacja podstawowych kolorów
	Subtle = theme.Subtle
	Highlight = theme.Highlight
	Special = theme.Special
	Error = theme.Error
	StatusBar = theme.StatusBar
	Border = theme.Border

	// Aktualizacja wszystkich stylów
	BaseStyle = lipgloss.NewStyle().
		Foreground(Subtle).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(Border)

	TitleStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(Highlight).
		MarginLeft(2)

	SelectedItemStyle = lipgloss.NewStyle().
		Foreground(Highlight).
		Bold(true)

	ItemStyle = lipgloss.NewStyle().
		Foreground(theme.ItemColor)

	DescriptionStyle = lipgloss.NewStyle().
		Foreground(Subtle).
		MarginLeft(2)

	Infotext = lipgloss.NewStyle().
		Foreground(theme.InfotextColor)
	InfotextStyle = Infotext

	HostStyle = lipgloss.NewStyle().
		Foreground(theme.HostColor)

	LabelStyle = lipgloss.NewStyle().
		Foreground(theme.LabelColor)

	InputStyle = lipgloss.NewStyle().
		Foreground(theme.InputColor).
		BorderStyle(lipgloss.NormalBorder()).
		BorderForeground(Highlight).
		Padding(0, 1)

	StatusConnectingStyle = lipgloss.NewStyle().
		Foreground(Highlight).
		Bold(true)

	StatusConnectedStyle = lipgloss.NewStyle().
		Foreground(Special).
		Bold(true)

	StatusDefaultStyle = lipgloss.NewStyle().
		Foreground(Subtle)

	StatusStyle = lipgloss.NewStyle().
		Foreground(StatusBar)

	PanelTitleStyle = lipgloss.NewStyle().
		Foreground(Highlight).
		Bold(true).
		Padding(0, 1)

	ButtonDisabledStyle = lipgloss.NewStyle().
		Foreground(Subtle).
		Bold(true)

	DescriptionDisabledStyle = lipgloss.NewStyle().
		Foreground(Subtle).
		MarginLeft(2)

	ButtonStyle = lipgloss.NewStyle().
		Foreground(Special).
		Bold(true)

	SuccessStyle = lipgloss.NewStyle().
		Foreground(Special).
		Bold(true)

	ErrorStyle = lipgloss.NewStyle().
		Foreground(Error).
		Bold(true)

	WindowStyle = lipgloss.NewStyle().
		BorderStyle(lipgloss.DoubleBorder()).
		BorderForeground(Border).
		Padding(1, 2)

	HeaderStyle = lipgloss.NewStyle().
		Foreground(Highlight).
		Bold(true).
		Underline(true).
		Padding(0, 1)

	CellStyle = lipgloss.NewStyle().
		Foreground(theme.InputColor).
		Padding(0, 1)

	DialogStyle = lipgloss.NewStyle().
		BorderStyle(lipgloss.RoundedBorder()).
		BorderForeground(Border).
		Padding(1, 2)

	DialogTitleStyle = lipgloss.NewStyle().
		Bold(true).
		Foreground(Highlight).
		Padding(0, 1)

	DialogButtonStyle = lipgloss.NewStyle().
		Foreground(Special).
		Bold(true).
		Padding(0, 2)

	PanelStyle = lipgloss.NewStyle().
		Border(lipgloss.NormalBorder()).
		BorderForeground(Border).
		Padding(0, 1)

	StatusBarStyle = lipgloss.NewStyle().
		Foreground(theme.InputColor).
		Background(StatusBar).
		Bold(true).
		Padding(0, 1).
		Width(103)

	CommandBarStyle = lipgloss.NewStyle().
		Foreground(theme.InputColor).
		Padding(0, 0).
		Width(103).
		BorderStyle(lipgloss.NormalBorder()).
		BorderTop(true).
		BorderForeground(Border)

	// Style dla plików
	DirectoryStyle = lipgloss.NewStyle().
		Foreground(theme.DirectoryColor).
		Bold(true)

	ExecutableStyle = lipgloss.NewStyle().
		Foreground(theme.ExecutableColor)

	ArchiveStyle = lipgloss.NewStyle().
		Foreground(theme.ArchiveColor)

	ImageStyle = lipgloss.NewStyle().
		Foreground(theme.ImageColor)

	DocumentStyle = lipgloss.NewStyle().
		Foreground(theme.DocumentColor)

	// Style dla kodu
	CodeCStyle = lipgloss.NewStyle().
		Foreground(theme.CodeCColor)

	CodeHStyle = lipgloss.NewStyle().
		Foreground(theme.CodeHColor)

	CodeGoStyle = lipgloss.NewStyle().
		Foreground(theme.CodeGoColor)

	CodePyStyle = lipgloss.NewStyle().
		Foreground(theme.CodePyColor)

	CodeJsStyle = lipgloss.NewStyle().
		Foreground(theme.CodeJsColor)

	CodeJsonStyle = lipgloss.NewStyle().
		Foreground(theme.CodeJsonColor)

	CodeDefaultStyle = lipgloss.NewStyle().
		Foreground(theme.CodeDefaultColor)

	DefaultFileStyle = lipgloss.NewStyle().
		Foreground(theme.DefaultFileColor)

	SelectedFileStyle = lipgloss.NewStyle().
		Foreground(theme.SelectedFileColor)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//themes.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/edit.go
// internal/ui/views/edit.go

package views

import (
	"fmt"
	"sshManager/internal/models"
	"sshManager/internal/ui"
	"strconv"
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type editMode int

const (
	modeNormal editMode = iota
	modeSelectPassword
	modeHostList
	modePasswordList
	modeKeyEdit // Nowy tryb dla edycji kluczy SSH
	modeKeyList // Nowy tryb dla listy kluczy
)

type editView struct {
	model                 *ui.Model
	activeField           int
	editing               bool
	editingHost           bool
	inputs                []textinput.Model
	keyTextarea           textarea.Model // Dodajemy pole na textarea
	currentHost           *models.Host
	currentPassword       *models.Password
	errorMsg              string
	mode                  editMode
	passwordList          []models.Password
	selectedPasswordIndex int
	tmpHost               *models.Host
	hosts                 []models.Host
	passwords             []models.Password
	selectedItemIndex     int
	deleteConfirmation    bool
	width                 int
	height                int
	currentKey            *models.Key
	keys                  []models.Key
	authTypePasswords     bool // true jeśli aktywna jest lista haseł, false jeśli lista kluczy
}

func NewEditView(model *ui.Model) *editView {
	v := &editView{
		model:                 model,
		inputs:                make([]textinput.Model, 6), // Name, Description, Login, IP, Port, Password
		width:                 model.GetTerminalWidth(),
		height:                model.GetTerminalHeight(),
		mode:                  modeNormal,
		activeField:           0,
		editing:               false,
		editingHost:           false,
		errorMsg:              "",
		selectedPasswordIndex: 0,
		selectedItemIndex:     0,
		deleteConfirmation:    false,
		hosts:                 make([]models.Host, 0),
		passwords:             make([]models.Password, 0),
		passwordList:          make([]models.Password, 0),
		keys:                  make([]models.Key, 0),
		authTypePasswords:     true,
	}

	// Initialize text inputs
	for i := range v.inputs {
		t := textinput.New()
		t.CharLimit = 64

		switch i {
		case 0:
			t.Placeholder = "Name"
			t.Focus()
		case 1:
			t.Placeholder = "Description"
			t.EchoMode = textinput.EchoNormal // Ensure it's normal text
		case 2:
			t.Placeholder = "Login"
		case 3:
			t.Placeholder = "IP/Host"
		case 4:
			t.Placeholder = "Port"
		case 5:
			t.Placeholder = "Password"
			t.EchoMode = textinput.EchoPassword
		}
		v.inputs[i] = t
	}

	return v
}

func (v *editView) Init() tea.Cmd {
	// aktualizacja list przy inicjalizacji
	v.model.UpdateLists()
	return textinput.Blink
}

func (v *editView) View() string {
	var content string
	contentWidth := min(v.width-40, 160)

	switch v.mode {
	case modePasswordList, modeKeyList: // Dodajemy modeKeyList do tego samego case'a
		content = v.renderPasswordList(contentWidth)
	case modeSelectPassword:
		content = v.renderAuthSelection(contentWidth)
	case modeKeyEdit: // Dodajemy osobny case dla edycji klucza
		if v.editing {
			content = v.renderKeyEdit(contentWidth)
		}
	default:
		if v.editing {
			if v.editingHost {
				content = v.renderHostEdit(contentWidth)
			} else {
				content = v.renderPasswordEdit(contentWidth)
			}
		}
	}

	if v.errorMsg != "" {
		content += "\n" + ui.ErrorStyle.Render(v.errorMsg)
	}

	finalContent := ui.WindowStyle.
		Width(contentWidth).
		Render(content)

	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Center,
		lipgloss.Center,
		finalContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

func (v *editView) resetState() {
	// Reset basic state
	v.activeField = 0
	v.errorMsg = ""
	v.currentHost = nil
	v.currentPassword = nil
	v.tmpHost = nil
	v.editing = false
	v.mode = modeNormal
	v.deleteConfirmation = false

	// Reset lists
	v.hosts = make([]models.Host, 0)
	v.passwords = make([]models.Password, 0)
	v.passwordList = make([]models.Password, 0)
	v.selectedItemIndex = 0
	v.selectedPasswordIndex = 0

	// Reset all inputs
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Refresh lists to ensure state consistency in main_view.go
	v.model.UpdateLists()
}

func (v *editView) renderAuthSelection(width int) string {
	var content strings.Builder
	content.WriteString(ui.TitleStyle.Render("Select Authentication Method") + "\n\n")

	// Pobieramy listy haseł i kluczy
	v.passwordList = v.model.GetPasswords()
	v.keys = v.model.GetKeys()

	if len(v.passwordList) == 0 && len(v.keys) == 0 {
		content.WriteString(ui.ErrorStyle.Render("No authentication methods available.\nPlease add a password or SSH key first.") + "\n")
		return content.String()
	}

	listWidth := width - 4 // Margines wewnętrzny

	// Najpierw wyświetlamy hasła
	if len(v.passwordList) > 0 {
		headerStyle := ui.LabelStyle
		if v.authTypePasswords {
			headerStyle = ui.SelectedItemStyle
		}
		content.WriteString(headerStyle.Render("Passwords:") + "\n")

		for i, pwd := range v.passwordList {
			prefix := "  "
			if v.authTypePasswords && i == v.selectedPasswordIndex {
				prefix = "> "
				line := fmt.Sprintf("%-*s", listWidth-1, prefix+pwd.Description)
				content.WriteString(ui.SelectedItemStyle.Render(line) + "\n")
			} else {
				line := fmt.Sprintf("%-*s", listWidth-1, prefix+pwd.Description)
				content.WriteString(line + "\n")
			}
		}
	}

	// Następnie wyświetlamy klucze SSH
	if len(v.keys) > 0 {
		if len(v.passwordList) > 0 {
			content.WriteString("\n")
		}
		headerStyle := ui.LabelStyle
		if !v.authTypePasswords {
			headerStyle = ui.SelectedItemStyle
		}
		content.WriteString(headerStyle.Render("SSH Keys:") + "\n")

		for i, key := range v.keys {
			prefix := "  "
			if !v.authTypePasswords && i == v.selectedPasswordIndex {
				prefix = "> "
				line := fmt.Sprintf("%-*s", listWidth-1, prefix+key.Description)
				content.WriteString(ui.SelectedItemStyle.Render(line) + "\n")
			} else {
				line := fmt.Sprintf("%-*s", listWidth-1, prefix+key.Description)
				content.WriteString(line + "\n")
			}
		}
	}

	content.WriteString("\n" + v.renderControls(
		Control{"↑↓", "Navigate"},
		Control{"Tab", "Switch section"},
		Control{"ENTER", "Select"},
		Control{"ESC", "Cancel"},
	))

	return content.String()
}

func (v *editView) renderPasswordList(width int) string {
	var content strings.Builder
	var items []struct {
		description string
		isSelected  bool
	}

	// Przygotowanie danych w zależności od trybu
	listWidth := width - 4
	if v.mode == modeKeyList {
		content.WriteString(ui.TitleStyle.Render("SSH Keys") + "\n\n")
		if len(v.keys) == 0 {
			content.WriteString(ui.DescriptionStyle.Render("No SSH keys available. Press 'a' to add a new key.") + "\n")
		} else {
			// Przygotuj listę kluczy
			for i, key := range v.keys {
				items = append(items, struct {
					description string
					isSelected  bool
				}{
					description: key.Description,
					isSelected:  i == v.selectedItemIndex,
				})
			}
		}
	} else {
		content.WriteString(ui.TitleStyle.Render("Password List") + "\n\n")
		if len(v.passwords) == 0 {
			content.WriteString(ui.DescriptionStyle.Render("No passwords available. Press 'a' to add a new password.") + "\n")
		} else {
			// Przygotuj listę haseł
			for i, pass := range v.passwords {
				items = append(items, struct {
					description string
					isSelected  bool
				}{
					description: pass.Description,
					isSelected:  i == v.selectedItemIndex,
				})
			}
		}
	}

	// Renderowanie listy (wspólne dla obu trybów)
	for _, item := range items {
		prefix := "  "
		if item.isSelected {
			prefix = "> "
			line := fmt.Sprintf("%-*s", listWidth-1, prefix+item.description)
			content.WriteString(ui.SelectedItemStyle.Render(line) + "\n")
		} else {
			line := fmt.Sprintf("%-*s", listWidth-1, prefix+item.description)
			content.WriteString(line + "\n")
		}
	}

	// Wspólne kontrolki dla obu trybów
	content.WriteString("\n" + v.renderControls(
		Control{"a", "Add"},
		Control{"e", "Edit"},
		Control{"d", "Delete"},
		Control{"ESC", "Back"},
	))

	return content.String()
}

// Helper struct for rendering controls
type Control struct {
	key         string
	description string
}

func (v *editView) renderControls(controls ...Control) string {
	var content strings.Builder
	for i, ctrl := range controls {
		if i > 0 {
			content.WriteString("    ") // Zwiększony odstęp między kontrolkami
		}
		content.WriteString(ui.ButtonStyle.Render(ctrl.key) + " - " + ctrl.description)
	}
	return content.String()
}

func (v *editView) renderPasswordEdit(width int) string {
	var content strings.Builder

	// Tytuł
	title := "Add New Password"
	if v.currentPassword != nil {
		title = "Edit Password"
	}
	content.WriteString(ui.TitleStyle.Render(title) + "\n\n")

	// Dopasowanie szerokości pól wejściowych
	inputWidth := width - 8 // Marginesy i ramki

	// Etykiety dla pól
	labels := []string{
		"Description:",
		"Password:",
	}

	// Renderowanie pól wejściowych
	for i, input := range v.inputs[:2] {
		content.WriteString(ui.LabelStyle.Render(labels[i]) + "\n")

		inputStyle := ui.InputStyle.Width(inputWidth)
		if i == v.activeField {
			inputStyle = ui.SelectedItemStyle.Width(inputWidth)
		}
		content.WriteString(inputStyle.Render(input.View()) + "\n\n")
	}

	// Dodanie kontroli na dole widoku
	content.WriteString(v.renderControls(
		Control{"ENTER", "Save"},
		Control{"ESC", "Cancel"},
		Control{"↑/↓", "Navigate"},
	))

	return content.String()
}

func (v *editView) renderHostEdit(width int) string {
	var content strings.Builder

	// Tytuł
	title := "Add New Host"
	if v.currentHost != nil {
		title = "Edit Host"
	}
	content.WriteString(ui.TitleStyle.Render(title) + "\n\n")

	// Dopasowanie szerokości pól wejściowych
	inputWidth := width - 8 // Marginesy i ramki

	// Etykiety dla pól
	labels := []string{
		"Host Name:",
		"Description:",
		"Login:",
		"IP/Host:",
		"Port:",
	}

	// Renderowanie pól wejściowych
	for i, input := range v.inputs[:5] {
		content.WriteString(ui.LabelStyle.Render(labels[i]) + "\n")

		inputStyle := ui.InputStyle.Width(inputWidth)
		if i == v.activeField {
			inputStyle = ui.SelectedItemStyle.Width(inputWidth)
		}
		content.WriteString(inputStyle.Render(input.View()) + "\n\n")
	}

	// Dodanie kontroli na dole widoku
	content.WriteString(v.renderControls(
		Control{"ENTER", "Save"},
		Control{"ESC", "Cancel"},
		Control{"↑/↓", "Navigate"},
	))

	return content.String()
}

func (v *editView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.width = msg.Width
		v.height = msg.Height
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		return v, nil

	case tea.KeyMsg:
		if v.mode == modePasswordList || v.mode == modeKeyList {
			switch msg.String() {
			case "tab", "shift+tab", "up", "down":
				return v.handleNavigationKey(msg.String())
			}
		}

		// Sprawdź, czy jesteśmy w trybie edycji
		if v.editing && v.mode != modeSelectPassword &&
			v.mode != modeHostList && v.mode != modePasswordList &&
			v.mode != modeKeyList {
			switch msg.String() {
			case "esc":
				model, cmd := v.handleEscapeKey()
				if _, ok := model.(*editView); !ok {
					return model, cmd
				}
				return v, cmd

			case "enter":
				model, cmd := v.handleEnterKey()
				if _, ok := model.(*editView); !ok {
					return model, cmd
				}
				return v, cmd

			case "tab", "shift+tab", "up", "down":
				return v.handleNavigationKey(msg.String())

			default:
				// Obsługa textarea dla trybu edycji klucza
				if v.mode == modeKeyEdit && v.activeField == 2 {
					v.keyTextarea, cmd = v.keyTextarea.Update(msg)
					return v, cmd
				}
				// Standardowa obsługa dla innych pól
				v.inputs[v.activeField], cmd = v.inputs[v.activeField].Update(msg)
				return v, cmd
			}
		}
		// Obsługuj klawisze w normalnym trybie
		switch msg.String() {
		case "esc":
			model, cmd := v.handleEscapeKey()
			if _, ok := model.(*editView); !ok {
				return model, cmd
			}
			return v, cmd

		case "tab", "shift+tab", "up", "down":
			return v.handleNavigationKey(msg.String())

		case "enter":
			model, cmd := v.handleEnterKey()
			if _, ok := model.(*editView); !ok {
				return model, cmd
			}
			return v, cmd

		case "e":
			if v.mode == modePasswordList || v.mode == modeKeyList {
				if v.mode == modePasswordList && len(v.passwords) > 0 {
					v.currentPassword = &v.passwords[v.selectedItemIndex]
					v.editingHost = false
					v.mode = modeNormal
					v.editing = true
					v.initializePasswordInputs()
				} else if v.mode == modeKeyList && len(v.keys) > 0 {
					v.currentKey = &v.keys[v.selectedItemIndex]
					v.mode = modeKeyEdit
					v.editing = true
					v.initializeKeyInputs()
				}
			}
			model, cmd := v.handleActionKey(msg.String())
			if _, ok := model.(*editView); !ok {
				return model, cmd
			}
			return v, cmd

		case "a":
			// Ujednolicona obsługa dodawania dla obu list
			if v.mode == modePasswordList {
				v.currentPassword = nil
				v.editingHost = false
				v.mode = modeNormal
				v.editing = true
				v.initializePasswordInputs()
				return v, nil
			} else if v.mode == modeKeyList {
				v.currentKey = nil
				v.mode = modeKeyEdit
				v.editing = true
				v.initializeKeyInputs()
				return v, nil
			}

		case "d":
			// Ujednolicona obsługa usuwania dla obu list
			if v.mode == modePasswordList || v.mode == modeKeyList {
				// Sprawdzenie czy lista jest pusta
				isEmpty := (v.mode == modePasswordList && len(v.passwords) == 0) ||
					(v.mode == modeKeyList && len(v.keys) == 0)
				if isEmpty {
					return v, nil
				}

				// Obsługa potwierdzenia usunięcia
				if !v.deleteConfirmation {
					v.errorMsg = "Press 'd' again to confirm deletion"
					v.deleteConfirmation = true
					return v, nil
				}

				// Wykonanie usunięcia
				var result interface{}
				if v.mode == modePasswordList {
					password := v.passwords[v.selectedItemIndex]
					result = v.model.DeletePassword(password.Description)
				} else {
					key := v.keys[v.selectedItemIndex]
					result = v.model.DeleteKey(key.Description)
				}

				// Obsługa błędów i aktualizacja stanu
				if result != nil {
					v.errorMsg = fmt.Sprint(result)
				} else {
					if err := v.model.SaveConfig(); err != nil {
						v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
						return v, nil
					}
					v.model.UpdateLists()

					// Aktualizacja odpowiedniej listy
					if v.mode == modePasswordList {
						v.passwords = v.model.GetPasswords()
						if v.selectedItemIndex >= len(v.passwords) {
							v.selectedItemIndex = len(v.passwords) - 1
						}
						v.model.SetStatus("Password deleted successfully", false)
					} else {
						v.keys = v.model.GetKeys()
						if v.selectedItemIndex >= len(v.keys) {
							v.selectedItemIndex = len(v.keys) - 1
						}
						v.model.SetStatus("Key deleted successfully", false)
					}
				}
				v.deleteConfirmation = false
			}
			return v, nil
		}
	}
	return v, cmd
}

// internal/ui/views/edit.go
func (v *editView) handleEscapeKey() (tea.Model, tea.Cmd) {
	switch v.mode {
	case modeSelectPassword:
		v.mode = modeNormal
		v.editing = false
		v.resetState()
		v.model.SetActiveView(ui.ViewMain)
		return NewMainView(v.model), nil

	case modeHostList, modePasswordList:
		v.mode = modeNormal
		v.editing = false
		v.resetState()
		v.model.SetActiveView(ui.ViewMain)
		return NewMainView(v.model), nil

	default:
		if !v.editing {
			v.model.SetStatus("", false)
			v.model.SetActiveView(ui.ViewMain)
			v.resetState()
			return NewMainView(v.model), nil
		}

		v.editing = false
		v.resetState()
		v.model.SetActiveView(ui.ViewMain)
		return NewMainView(v.model), nil
	}
}

func (v *editView) handleNavigationKey(key string) (tea.Model, tea.Cmd) {
	switch v.mode {
	case modeSelectPassword:
		v.navigatePasswordSelection(key)
		return v, nil

	case modePasswordList, modeKeyList:
		v.navigateList(key)
		return v, nil

	default:
		if v.editing {
			v.navigateFields(key)
		}
	}
	return v, nil
}

func (v *editView) navigatePasswordSelection(key string) {
	switch key {
	case "tab":
		// Przełączanie między hasłami a kluczami
		v.authTypePasswords = !v.authTypePasswords
		v.selectedPasswordIndex = 0 // Reset indeksu przy przełączaniu

	case "up", "shift+tab":
		if v.authTypePasswords {
			if len(v.passwordList) > 0 {
				v.selectedPasswordIndex--
				if v.selectedPasswordIndex < 0 {
					v.selectedPasswordIndex = len(v.passwordList) - 1
				}
			}
		} else {
			if len(v.keys) > 0 {
				v.selectedPasswordIndex--
				if v.selectedPasswordIndex < 0 {
					v.selectedPasswordIndex = len(v.keys) - 1
				}
			}
		}

	case "down":
		if v.authTypePasswords {
			if len(v.passwordList) > 0 {
				v.selectedPasswordIndex++
				if v.selectedPasswordIndex >= len(v.passwordList) {
					v.selectedPasswordIndex = 0
				}
			}
		} else {
			if len(v.keys) > 0 {
				v.selectedPasswordIndex++
				if v.selectedPasswordIndex >= len(v.keys) {
					v.selectedPasswordIndex = 0
				}
			}
		}
	}
}

func (v *editView) navigateList(key string) {
	var maxItems int
	switch v.mode {
	case modePasswordList:
		maxItems = len(v.passwords)
	case modeKeyList:
		maxItems = len(v.keys)
	default:
		maxItems = len(v.hosts)
	}

	if key == "up" || key == "shift+tab" {
		v.selectedItemIndex--
		if v.selectedItemIndex < 0 {
			v.selectedItemIndex = maxItems - 1
		}
	} else {
		v.selectedItemIndex++
		if v.selectedItemIndex >= maxItems {
			v.selectedItemIndex = 0
		}
	}
}

func (v *editView) navigateFields(key string) {
	if key == "up" || key == "shift+tab" {
		v.activeField--
	} else {
		v.activeField++
	}

	var maxFields int
	switch {
	case v.editingHost:
		maxFields = 5 // For host editing
	case v.mode == modeKeyEdit:
		maxFields = 3 // For key editing
	default:
		maxFields = 2 // For password editing
	}

	// Wrap around navigation
	if v.activeField >= maxFields {
		v.activeField = 0
	} else if v.activeField < 0 {
		v.activeField = maxFields - 1
	}

	// Update focus
	for i := range v.inputs {
		if i == v.activeField {
			v.inputs[i].Focus()
		} else {
			v.inputs[i].Blur()
		}
	}
}

func (v *editView) handleActionKey(key string) (tea.Model, tea.Cmd) {
	switch v.mode {
	case modePasswordList:
		if len(v.passwords) == 0 {
			return v, nil
		}
		return v.handlePasswordListAction(key)
	}
	return v, nil
}

func (v *editView) handlePasswordListAction(key string) (tea.Model, tea.Cmd) {
	switch key {
	case "e":
		// Edytuj wybrane hasło
		v.currentPassword = &v.passwords[v.selectedItemIndex]
		v.editingHost = false
		v.mode = modeNormal
		v.initializePasswordInputs()
		return v, nil

	case "d":
		if !v.deleteConfirmation {
			v.errorMsg = "Press 'd' again to confirm deletion"
			v.deleteConfirmation = true
			return v, nil
		}

		// Usuń wybrane hasło
		password := v.passwords[v.selectedItemIndex]
		if err := v.model.DeletePassword(password.Description); err != nil {
			v.errorMsg = fmt.Sprint(err)
		} else {
			// Zapisz konfigurację po usunięciu hasła
			if err := v.model.SaveConfig(); err != nil {
				v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
				return v, nil
			}
			v.model.UpdateLists()
			v.passwords = v.model.GetPasswords()
			if v.selectedItemIndex >= len(v.passwords) {
				v.selectedItemIndex = len(v.passwords) - 1
			}
			v.model.SetStatus("Password deleted successfully", false)
		}
		v.deleteConfirmation = false

		// Przekierowanie na widok główny po usunięciu
		v.model.SetActiveView(ui.ViewMain)
		return v, nil
	}
	return v, nil
}

func (v *editView) handleEnterKey() (tea.Model, tea.Cmd) {
	switch {
	case v.mode == modeSelectPassword:
		model, cmd := v.saveHostWithPassword()
		if _, ok := model.(*editView); ok {
			// Jeśli wystąpił błąd, pozostań w widoku edycji
			return model, cmd
		}
		v.model.SetActiveView(ui.ViewMain)
		v.model.UpdateLists()
		return model, cmd

	case v.mode == modeHostList, v.mode == modePasswordList:
		return v, nil

	case !v.editing:
		v.editing = true
		v.editingHost = true
		v.initializeHostInputs()
		return v, nil

	default:
		model, cmd := v.handleSave()
		if _, ok := model.(*editView); ok {
			// Jeśli wystąpił błąd, pozostań w widoku edycji
			return model, cmd
		}
		v.model.UpdateLists()
		return model, cmd
	}
}

func (v *editView) handleSave() (tea.Model, tea.Cmd) {
	if v.editingHost {
		// Save host and handle accordingly
		model, cmd := v.validateAndSaveHost()
		if _, ok := model.(*editView); ok {
			// If there was an error, stay in edit view
			return model, cmd
		}
		// If validation passed, proceed as needed
		return model, cmd
	}

	if v.mode == modeKeyEdit {
		// Validation of key fields
		description := v.inputs[0].Value()
		path := v.inputs[1].Value()
		keyData := v.keyTextarea.Value()

		if description == "" {
			v.errorMsg = "description is required"
			return v, nil
		}

		if path != "" && keyData != "" {
			v.errorMsg = "cannot specify both path and key data"
			return v, nil
		}

		if path == "" && keyData == "" {
			v.errorMsg = "either path or key data must be provided"
			return v, nil
		}

		// Dodatkowa walidacja dla klucza SSH
		if keyData != "" {
			if !strings.Contains(keyData, "-----BEGIN") || !strings.Contains(keyData, "-----END") {
				v.errorMsg = "invalid SSH key format"
				return v, nil
			}

			// Preprocessing klucza SSH
			keyData = strings.TrimSpace(keyData)
			keyData = strings.ReplaceAll(keyData, "\r\n", "\n")
			keyData = strings.ReplaceAll(keyData, "\r", "\n")

			// Dodajemy pojedynczy znak nowej linii na końcu jeśli go nie ma
			if !strings.HasSuffix(keyData, "\n") {
				keyData += "\n"
			}
		}

		// Create new key
		key, err := models.NewKey(
			description,
			path,
			keyData,
			v.model.GetCipher(),
		)
		if err != nil {
			v.errorMsg = err.Error()
			return v, nil
		}

		// Update or add key
		if v.currentKey != nil {
			err = v.model.UpdateKey(v.currentKey.Description, key)
		} else {
			err = v.model.AddKey(key)
		}
		if err != nil {
			v.errorMsg = err.Error()
			return v, nil
		}
	} else {
		// Validation of password fields
		if err := v.validatePasswordFields(); err != nil {
			v.errorMsg = err.Error()
			return v, nil
		}
		// Creating new password with encryption
		password, err := models.NewPassword(v.inputs[0].Value(), v.inputs[1].Value(), v.model.GetCipher())
		if err != nil {
			v.errorMsg = fmt.Sprintf("Failed to create password: %v", err)
			return v, nil
		}
		// Update or add password
		if v.currentPassword != nil {
			if err := v.model.UpdatePassword(v.currentPassword.Description, password); err != nil {
				v.errorMsg = fmt.Sprint(err)
				return v, nil
			}
		} else {
			if err := v.model.AddPassword(password); err != nil {
				v.errorMsg = fmt.Sprint(err)
				return v, nil
			}
		}
	}

	// Save configuration
	if err := v.model.SaveConfig(); err != nil {
		v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
		return v, nil
	}

	// Update UI state
	v.model.UpdateLists()
	v.model.SetStatus("Configuration saved successfully", false)
	v.editing = false
	v.resetState()

	// Redirect to main view
	v.model.SetActiveView(ui.ViewMain)
	return NewMainView(v.model), nil
}

func (v *editView) validateAndSaveHost() (tea.Model, tea.Cmd) {
	// Sprawdź poprawność pól
	if err := v.validateHostFields(); err != nil {
		v.errorMsg = err.Error()
		return v, nil
	}

	// Sprawdź dostępne hasła
	passwords := v.model.GetPasswords()
	if len(passwords) == 0 {
		v.errorMsg = "Please add a password first"
		return v, nil
	}

	// Zainicjalizuj tymczasowego hosta
	v.tmpHost = &models.Host{
		Name:        v.inputs[0].Value(),
		Description: v.inputs[1].Value(),
		Login:       v.inputs[2].Value(),
		IP:          v.inputs[3].Value(),
		Port:        v.inputs[4].Value(),
	}

	// Przejdź do trybu wyboru hasła
	v.mode = modeSelectPassword
	v.passwordList = passwords
	v.selectedPasswordIndex = 0
	return v, nil
}

func (v *editView) saveHostWithPassword() (tea.Model, tea.Cmd) {
	if v.authTypePasswords {
		// Dla haseł używamy indeksu dodatniego
		v.tmpHost.PasswordID = v.selectedPasswordIndex
	} else {
		// Dla kluczy używamy indeksu ujemnego
		v.tmpHost.PasswordID = -(v.selectedPasswordIndex + 1) // +1 żeby uniknąć problemu z zerem
	}

	// Aktualizacja lub dodanie hosta
	var err interface{}
	if v.currentHost != nil {
		err = v.model.UpdateHost(v.currentHost.Name, v.tmpHost)
	} else {
		err = v.model.AddHost(v.tmpHost)
	}

	if err != nil {
		v.errorMsg = fmt.Sprint(err)
		return v, nil
	}

	// Zapis konfiguracji
	if err := v.model.SaveConfig(); err != nil {
		v.errorMsg = fmt.Sprintf("Failed to save configuration: %v", err)
		return v, nil
	}

	// Aktualizacja stanu UI
	v.mode = modeNormal
	v.model.UpdateLists()
	v.model.SetStatus("Host saved successfully", false)
	v.editing = false
	v.resetState()

	// Przekierowanie na widok główny
	v.model.SetActiveView(ui.ViewMain)
	return NewMainView(v.model), nil
}

func (v *editView) initializeHostInputs() {
	// Reset all inputs first
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Set default values or current host values
	if v.currentHost != nil {
		v.inputs[0].SetValue(v.currentHost.Name)
		v.inputs[1].SetValue(v.currentHost.Description)
		v.inputs[2].SetValue(v.currentHost.Login)
		v.inputs[3].SetValue(v.currentHost.IP)
		v.inputs[4].SetValue(v.currentHost.Port)
	}

	// Configure field properties
	v.inputs[0].Placeholder = "Host name"
	v.inputs[1].Placeholder = "Description"
	v.inputs[1].EchoMode = textinput.EchoNormal
	v.inputs[2].Placeholder = "Username"
	v.inputs[3].Placeholder = "IP address or hostname"
	v.inputs[4].Placeholder = "Port number"

	// Focus the first field
	v.activeField = 0
	v.inputs[0].Focus()
}

func (v *editView) initializePasswordInputs() {
	// Reset all inputs first
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Set default values or current password values
	if v.currentPassword != nil {
		v.inputs[0].SetValue(v.currentPassword.Description)
		// Don't set the password value for security reasons
	}

	// Configure field properties
	v.inputs[0].Placeholder = "Password description"
	v.inputs[1].Placeholder = "Enter password"
	v.inputs[1].EchoMode = textinput.EchoPassword

	// Focus the first field
	v.activeField = 0
	v.inputs[0].Focus()
}

// Helper function to check if a field contains only digits
func isNumeric(s string) bool {
	num, err := strconv.Atoi(s)
	if err != nil {
		return false
	}
	// Sprawdź czy numer portu jest w prawidłowym zakresie (1-65535)
	return num > 0 && num <= 65535
}

// Helper function to validate host fields
func (v *editView) validateHostFields() error {
	if v.inputs[0].Value() == "" {
		return fmt.Errorf("host name is required")
	}
	if v.inputs[2].Value() == "" {
		return fmt.Errorf("login is required")
	}
	if v.inputs[3].Value() == "" {
		return fmt.Errorf("IP/hostname is required")
	}
	if !isNumeric(v.inputs[4].Value()) {
		return fmt.Errorf("port must be a valid number")
	}
	port, _ := strconv.Atoi(v.inputs[4].Value())
	if port < 1 || port > 65535 {
		return fmt.Errorf("port must be between 1 and 65535")
	}
	return nil
}

// Helper function to validate password fields
func (v *editView) validatePasswordFields() error {
	if v.inputs[0].Value() == "" {
		return fmt.Errorf("password description is required")
	}
	if v.inputs[1].Value() == "" {
		return fmt.Errorf("password value is required")
	}
	if len(v.inputs[1].Value()) < 6 {
		return fmt.Errorf("password must be at least 6 characters long")
	}
	return nil
}

func (v *editView) initializeKeyInputs() {
	// Reset all inputs first
	for i := range v.inputs {
		v.inputs[i].Reset()
		v.inputs[i].Blur()
	}

	// Konfiguracja pól dla klucza SSH
	v.inputs[0].Placeholder = "Key description"
	v.inputs[0].CharLimit = 64
	v.inputs[0].Focus()

	v.inputs[1].Placeholder = "Key path (optional)"
	v.inputs[1].CharLimit = 256

	// Inicjalizacja textarea dla klucza
	v.keyTextarea = textarea.New()
	v.keyTextarea.Placeholder = "Paste SSH key here (optional)"
	v.keyTextarea.ShowLineNumbers = false
	v.keyTextarea.CharLimit = 4096

	// Jeśli edytujemy istniejący klucz
	if v.currentKey != nil {
		v.inputs[0].SetValue(v.currentKey.Description)
		path, err := v.currentKey.GetKeyPath()
		if err == nil {
			v.inputs[1].SetValue(path)
		}
	}

	// Ustaw fokus na pierwsze pole
	v.activeField = 0
	v.inputs[0].Focus()
}

func (v *editView) renderKeyEdit(width int) string {
	var content strings.Builder

	// Tytuł
	title := "Add New SSH Key"
	if v.currentKey != nil {
		title = "Edit SSH Key"
	}
	content.WriteString(ui.TitleStyle.Render(title) + "\n\n")

	// Dopasowanie szerokości pól wejściowych
	inputWidth := width - 8 // Marginesy i ramki

	// Etykiety dla pól
	labels := []string{
		"Description:",
		"Key Path (optional):",
		"Key Data (optional):",
	}

	// Renderowanie pól description i path
	for i := 0; i < 2; i++ {
		content.WriteString(ui.LabelStyle.Render(labels[i]) + "\n")
		inputStyle := ui.InputStyle.Width(inputWidth)
		if i == v.activeField {
			inputStyle = ui.SelectedItemStyle.Width(inputWidth)
		}
		content.WriteString(inputStyle.Render(v.inputs[i].View()) + "\n\n")
	}

	// Renderowanie textarea dla klucza
	content.WriteString(ui.LabelStyle.Render(labels[2]) + "\n")
	v.keyTextarea.SetWidth(inputWidth)
	v.keyTextarea.SetHeight(10) // Wysokość pola na klucz
	textareaStyle := ui.InputStyle
	if v.activeField == 2 {
		textareaStyle = ui.SelectedItemStyle
		if !v.keyTextarea.Focused() {
			v.keyTextarea.Focus()
		}
	} else {
		v.keyTextarea.Blur()
	}
	content.WriteString(textareaStyle.Render(v.keyTextarea.View()) + "\n\n")

	// Dodanie informacji pomocniczej
	content.WriteString(ui.DescriptionStyle.Render(
		"Note: Provide either Key Path or Key Data, not both\n\n"))

	// Dodanie kontroli na dole widoku
	content.WriteString(v.renderControls(
		Control{"ENTER", "Save"},
		Control{"ESC", "Cancel"},
		Control{"↑/↓", "Navigate"},
	))

	return content.String()
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/edit.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/initial_prompt.go
package views

import (
	"sshManager/internal/crypto"
	"sshManager/internal/ui"
	"sshManager/internal/ui/messages"
	"strings"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type initialPromptModel struct {
	password      []rune
	configPath    string
	errorMessage  string
	width, height int
}

type ApiKeyPromptModel struct {
	input        textinput.Model
	configPath   string
	errorMessage string
	width        int
	height       int
	cipher       *crypto.Cipher
}

func NewApiKeyPromptModel(configPath string, cipher *crypto.Cipher) *ApiKeyPromptModel {
	input := textinput.New()
	input.Placeholder = "Enter API key (or press ESC for local mode)"
	input.Focus()

	return &ApiKeyPromptModel{
		input:      input,
		configPath: configPath,
		cipher:     cipher,
	}
}

func NewInitialPromptModel(configPath string) *initialPromptModel {
	return &initialPromptModel{
		password:   []rune{},
		configPath: configPath,
	}
}

func (m *initialPromptModel) Init() tea.Cmd {
	return nil
}

func (m *initialPromptModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		return m, nil

	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyRunes:
			m.password = append(m.password, msg.Runes...)
		case tea.KeyBackspace, tea.KeyDelete:
			if len(m.password) > 0 {
				m.password = m.password[:len(m.password)-1]
			}
		case tea.KeyEnter:
			if len(m.password) == 0 {
				m.errorMessage = "Password cannot be empty"
				return m, nil
			}
			// Wyczyść ekran i wyślij hasło
			return m, tea.Sequence(
				tea.ClearScreen,
				func() tea.Msg {
					return tea.WindowSizeMsg{
						Width:  m.width,
						Height: m.height,
					}
				},
				func() tea.Msg {
					return messages.PasswordEnteredMsg(string(m.password))
				},
			)
		case tea.KeyCtrlC:
			return m, tea.Quit
		}
	}
	return m, nil
}

func (m *initialPromptModel) View() string {
	// Definicja stylów
	asciiArtStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#7DC4E4")).
		Bold(true)

	infoStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#A6ADC8")).
		Italic(true)

	promptStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FFFFFF")).
		Bold(true)

	errorStyle := ui.ErrorStyle

	// ASCII Art
	asciiArt := `
         _     __  __                                   
 ___ ___| |__ |  \/  | __ _ _ __   __ _  __ _  ___ _ __ 
/ __/ __| '_ \| |\/| |/ _' | '_ \ / _' |/ _' |/ _ \ '__|
\__ \__ \ | | | |  | | (_| | | | | (_| | (_| |  __/ |   
|___/___/_| |_|_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|   
                        https://sshm.io |___/`

	asciiArtRendered := asciiArtStyle.Render(asciiArt)

	// Informacja o pliku konfiguracyjnym
	configInfo := infoStyle.Render("Using config file: " + m.configPath)

	// Pytanie o hasło
	passwordPrompt := promptStyle.Render("Enter encryption key: ")
	maskedPassword := strings.Repeat("*", len(m.password))

	// Połączenie wszystkich elementów
	content := lipgloss.JoinVertical(
		lipgloss.Center,
		asciiArtRendered,
		"",
		configInfo,
		"",
		passwordPrompt+maskedPassword,
	)

	// Dodanie komunikatu o błędzie, jeśli istnieje
	if m.errorMessage != "" {
		content += "\n" + errorStyle.Render(m.errorMessage)
	}

	// Ramka wokół zawartości
	frameStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#7DC4E4")).
		Padding(1, 2)

	framedContent := frameStyle.Render(content)

	// Wyśrodkowanie zawartości
	finalContent := lipgloss.Place(
		m.width, m.height,
		lipgloss.Center, lipgloss.Center,
		framedContent,
	)

	return finalContent
}

func (m *ApiKeyPromptModel) Init() tea.Cmd {
	return textinput.Blink // Dodane dla migającego kursora w polu input
}

func (m *ApiKeyPromptModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		return m, nil

	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyEsc:
			// Użytkownik wybrał tryb lokalny
			return m, tea.Sequence(
				tea.ClearScreen,
				func() tea.Msg {
					return tea.WindowSizeMsg{
						Width:  m.width,
						Height: m.height,
					}
				},
				func() tea.Msg {
					return messages.ApiKeyEnteredMsg{
						Key:       "",
						LocalMode: true,
					}
				},
			)

		case tea.KeyEnter:
			apiKey := m.input.Value()
			if len(apiKey) == 0 {
				m.errorMessage = "API key cannot be empty. Press ESC for local mode."
				return m, nil
			}

			// Sprawdź podstawową walidację klucza API (np. minimalna długość)
			if len(apiKey) < 32 {
				m.errorMessage = "Invalid API key format"
				return m, nil
			}

			return m, tea.Sequence(
				tea.ClearScreen,
				func() tea.Msg {
					return tea.WindowSizeMsg{
						Width:  m.width,
						Height: m.height,
					}
				},
				func() tea.Msg {
					return messages.ApiKeyEnteredMsg{
						Key:       apiKey,
						LocalMode: false,
					}
				},
			)

		case tea.KeyCtrlC:
			return m, tea.Quit
		}

		// Obsługa wprowadzania tekstu
		var cmd tea.Cmd
		m.input, cmd = m.input.Update(msg)
		return m, cmd
	}

	return m, nil
}

func (m *ApiKeyPromptModel) View() string {
	// Definicja stylów
	asciiArtStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#7DC4E4")).
		Bold(true)

	infoStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#A6ADC8")).
		Italic(true)

	promptStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FFFFFF")).
		Bold(true)

	errorStyle := ui.ErrorStyle

	// ASCII Art - ten sam co w pierwotnym pliku
	asciiArt := `
         _     __  __                                   
 ___ ___| |__ |  \/  | __ _ _ __   __ _  __ _  ___ _ __ 
/ __/ __| '_ \| |\/| |/ _' | '_ \ / _' |/ _' |/ _ \ '__|
\__ \__ \ | | | |  | | (_| | | | | (_| | (_| |  __/ |   
|___/___/_| |_|_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|   
                        https://sshm.io |___/`

	asciiArtRendered := asciiArtStyle.Render(asciiArt)

	// Informacje
	configInfo := infoStyle.Render("Using config file: " + m.configPath)

	apiInfo := infoStyle.Render("Press ESC to work in local mode without synchronization\n" +
		"If you don't have an API key, please register at https://sshm.io")

	// Prompt dla API key
	apiKeyPrompt := promptStyle.Render("Enter API key: ")
	maskedApiKey := strings.Repeat("*", len(m.input.Value()))

	// Połączenie wszystkich elementów
	content := lipgloss.JoinVertical(
		lipgloss.Center,
		asciiArtRendered,
		"",
		configInfo,
		"",
		apiInfo,
		"",
		apiKeyPrompt+maskedApiKey,
	)

	// Dodanie komunikatu o błędzie, jeśli istnieje
	if m.errorMessage != "" {
		content += "\n" + errorStyle.Render(m.errorMessage)
	}

	// Ramka wokół zawartości
	frameStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#7DC4E4")).
		Padding(1, 2)

	framedContent := frameStyle.Render(content)

	// Wyśrodkowanie zawartości
	finalContent := lipgloss.Place(
		m.width,
		m.height,
		lipgloss.Center,
		lipgloss.Center,
		framedContent,
	)

	return finalContent
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/initial_prompt.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/main_view.go
package views

import (
	"fmt"
	"path/filepath"
	"sshManager/internal/config"
	"sshManager/internal/models"
	"sshManager/internal/sync"
	"sshManager/internal/ui"
	"strings"
	"time"

	"sshManager/internal/ssh"

	"sshManager/internal/ui/components"
	"sshManager/internal/ui/messages"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/charmbracelet/lipgloss/table"
)

type mainView struct {
	model                     *ui.Model
	hosts                     []models.Host
	selectedIndex             int
	currentDir                string
	showHostList              bool
	errMsg                    string
	status                    string
	connecting                bool
	width                     int
	height                    int
	escPressed                bool
	escTimeout                *time.Timer
	waitingForKeyConfirmation bool
	hostKeyFingerprint        string
	pendingConnection         struct {
		host     *models.Host
		password string
	}
	popup *components.Popup // Dodane nowe pole

}

type connectError string
type errMsg string

type connectFinishedMsg struct {
	err error
}

func (e connectError) Error() string {
	return string(e)
}

func NewMainView(model *ui.Model) *mainView {
	return &mainView{
		model:        model,
		showHostList: true,
		hosts:        model.GetHosts(),
		currentDir:   getHomeDir(),
		width:        model.GetTerminalWidth(),  // Dodane
		height:       model.GetTerminalHeight(), // Dodane

	}
}

func (v *mainView) Init() tea.Cmd {
	return tea.Sequence(
		tea.EnterAltScreen,
		tea.ClearScreen,
	)
}

func (v *mainView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.width = msg.Width
		v.height = msg.Height
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		return v, nil

	case errMsg:
		v.errMsg = string(msg)
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Error",
			string(msg),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil

	case messages.ReloadAppMsg:
		v.model.SetQuitting(true)
		return v, tea.Quit

	case tea.KeyMsg:
		// Obsługa klawiszy dla popupu
		if v.popup != nil {
			switch msg.String() {
			case "esc", "enter":
				if v.popup.Type == components.PopupMessage {
					v.popup = nil
					return v, nil
				}
			// w main_view.go

			case "y", "Y":
				if v.popup.Type == components.PopupHostKey && v.waitingForKeyConfirmation {
					v.waitingForKeyConfirmation = false

					// Tworzymy instancję SSHClient
					sshClient := ssh.NewSSHClient(v.model.GetPasswords())
					err := sshClient.ConnectWithAcceptedKey(
						v.pendingConnection.host,
						v.pendingConnection.password,
					)

					if err != nil {
						v.popup = components.NewPopup(
							components.PopupMessage,
							"Błąd połączenia",
							fmt.Sprintf("Failed to connect: %v", err),
							50,
							7,
							v.width,
							v.height,
						)
						return v, nil
					}

					// Zapisujemy klienta SSH w modelu
					v.model.SetSSHClient(sshClient)

					v.connecting = true
					v.popup = components.NewPopup(
						components.PopupMessage,
						"SSH",
						"Connecting...",
						50,
						7,
						v.width,
						v.height,
					)

					return v, nil
				}
			case "n", "N":
				if v.popup.Type == components.PopupHostKey && v.waitingForKeyConfirmation {
					v.waitingForKeyConfirmation = false
					v.popup = components.NewPopup(
						components.PopupMessage,
						"SSH",
						"Connection cancelled",
						50,
						7,
						v.width,
						v.height,
					)
					return v, nil
				}
			}
			return v, nil
		}

		// Standardowa obsługa klawiszy nawigacji
		switch msg.String() {
		case "q", "ctrl+c":
			v.model.SetQuitting(true)
			return v, tea.Quit

		case "up", "w":
			if len(v.hosts) > 0 && !v.connecting {
				v.selectedIndex--
				if v.selectedIndex < 0 {
					v.selectedIndex = len(v.hosts) - 1
				}
				v.errMsg = ""
			}

		case "down", "s":
			if len(v.hosts) > 0 && !v.connecting {
				v.selectedIndex++
				if v.selectedIndex >= len(v.hosts) {
					v.selectedIndex = 0
				}
				v.errMsg = ""
			}
		case "enter", "c":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleConnect()
		case "k":
			if !v.connecting {
				editView := NewEditView(v.model)
				editView.mode = modeKeyList
				editView.editing = true
				editView.keys = v.model.GetKeys()
				editView.selectedItemIndex = 0
				return editView, nil
			}
		case "e", "f4":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			editView := NewEditView(v.model)
			editView.currentHost = &v.hosts[v.selectedIndex]
			editView.editingHost = true
			editView.editing = true
			editView.mode = modeNormal
			editView.initializeHostInputs()
			return editView, nil

		case "h":
			if !v.connecting {
				editView := NewEditView(v.model)
				editView.editingHost = true
				editView.editing = true
				editView.mode = modeNormal
				editView.initializeHostInputs()
				return editView, nil
			}

		case "p":
			if !v.connecting {
				editView := NewEditView(v.model)
				editView.mode = modePasswordList
				editView.editing = true
				editView.passwords = v.model.GetPasswords()
				editView.selectedItemIndex = 0
				return editView, nil
			}

		case "t":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleTransfer()

		case "d", "f8":
			if v.connecting || len(v.hosts) == 0 {
				return v, nil
			}
			return v.handleDelete()
		case " ":
			if !v.connecting && len(v.hosts) > 0 {
				ui.SwitchTheme()
				return v, nil
			}
		case "ctrl+r":
			return v.handleRestoreBackup()
		case "esc":
			v.escPressed = true
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			v.escTimeout = time.NewTimer(500 * time.Millisecond)
			go func() {
				<-v.escTimeout.C
				v.escPressed = false
			}()
			return v, nil
		}

		// Obsługa sekwencji ESC
		if v.escPressed {
			switch msg.String() {
			case "4":
				if len(v.hosts) > 0 && !v.connecting {
					editView := NewEditView(v.model)
					editView.currentHost = &v.hosts[v.selectedIndex]
					editView.editingHost = true
					editView.editing = true
					editView.mode = modeNormal
					editView.initializeHostInputs()
					return editView, nil
				}
				v.escPressed = false
				return v, nil
			case "8":
				if len(v.hosts) > 0 && !v.connecting {
					return v.handleDelete()
				}
				v.escPressed = false
				return v, nil
			}
			v.escPressed = false
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			return v, nil
		}

	case connectFinishedMsg:
		v.connecting = false
		if msg.err != nil {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Błąd połączenia",
				fmt.Sprintf("SSH connection failed: %v", msg.err),
				50,
				7,
				v.width,
				v.height,
			)
		} else {
			v.popup = nil
		}
		return v, nil

	case connectError:
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Błąd połączenia",
			msg.Error(),
			50,
			7,
			v.width,
			v.height,
		)
		v.connecting = false
		return v, nil
	}

	return v, nil
}

func (v *mainView) handleConnect() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	v.model.SetSelectedHost(&host)

	var authData string
	var err error

	if host.PasswordID < 0 {
		// Obsługa klucza SSH
		keyIndex := -(host.PasswordID + 1) // Konwertujemy ujemny indeks na właściwy indeks klucza
		keys := v.model.GetKeys()
		if keyIndex >= len(keys) {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Connection Error",
				"Invalid key ID",
				50,
				7,
				v.width,
				v.height,
			)
			return v, nil
		}
		key := keys[keyIndex]
		keyPath, err := key.GetKeyPath()
		if err != nil {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Connection Error",
				fmt.Sprintf("Failed to get key path: %v", err),
				50,
				7,
				v.width,
				v.height,
			)
			return v, nil
		}
		authData = keyPath
	} else {
		// Obsługa hasła
		passwords := v.model.GetPasswords()
		if host.PasswordID >= len(passwords) {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Connection Error",
				"Invalid password ID",
				50,
				7,
				v.width,
				v.height,
			)
			return v, nil
		}
		password := passwords[host.PasswordID]
		decryptedPass, err := password.GetDecrypted(v.model.GetCipher())
		if err != nil {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Connection Error",
				fmt.Sprintf("Failed to decrypt password: %v", err),
				50,
				7,
				v.width,
				v.height,
			)
			return v, nil
		}
		authData = decryptedPass
	}

	sshClient := ssh.NewSSHClient(v.model.GetPasswords())

	// Próba połączenia
	err = sshClient.Connect(&host, authData)
	if err != nil {
		// Sprawdzamy czy to błąd weryfikacji klucza
		if verificationRequired, ok := err.(*ssh.HostKeyVerificationRequired); ok {
			fingerprint, err := ssh.GetHostKeyFingerprint(&host)
			if err != nil {
				v.popup = components.NewPopup(
					components.PopupMessage,
					"Key Verification Error",
					fmt.Sprintf("Cannot retrieve key fingerprint: %v", err),
					50,
					7,
					v.width,
					v.height,
				)
				return v, nil
			}
			// Ustawiamy stan oczekiwania na potwierdzenie klucza
			v.waitingForKeyConfirmation = true
			v.hostKeyFingerprint = fingerprint
			v.pendingConnection.host = &host
			v.pendingConnection.password = authData
			v.popup = components.NewPopup(
				components.PopupHostKey,
				"Host Key Verification",
				fmt.Sprintf("New host key for %s:%s\n\nKey fingerprint:\n%s\n",
					verificationRequired.IP, verificationRequired.Port, fingerprint),
				70,
				12,
				v.width,
				v.height,
			)
			return v, nil
		}

		// Inny błąd połączenia
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Connection Error",
			fmt.Sprintf("Failed to connect: %v", err),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil
	}

	// Jeśli połączenie się udało, zapisujemy klienta
	v.model.SetSSHClient(sshClient)
	v.connecting = true
	v.popup = components.NewPopup(
		components.PopupMessage,
		"SSH",
		"Connecting...",
		50,
		7,
		v.width,
		v.height,
	)

	// Zwracamy komendę monitorującą stan połączenia
	return v, func() tea.Msg {
		// Monitorowanie stanu sesji w osobnym goroutine
		go func() {
			for {
				if sshClient.Session() != nil {
					state := sshClient.Session().GetState()
					if state == ssh.StateDisconnected || state == ssh.StateError {
						v.model.Program.Send(connectFinishedMsg{
							err: sshClient.Session().GetLastError(),
						})
						return
					}
				}
				time.Sleep(100 * time.Millisecond)
			}
		}()

		return connectFinishedMsg{err: nil}
	}
}

func (v *mainView) handleDelete() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	if err := v.model.DeleteHost(host.Name); err != nil {
		v.errMsg = fmt.Sprintf("Failed to delete host: %v", err)
	} else {
		if err := v.model.SaveConfig(); err != nil {
			v.errMsg = fmt.Sprintf("Failed to save configuration: %v", err)
			return v, nil
		}
		v.hosts = v.model.GetHosts()
		if v.selectedIndex >= len(v.hosts) {
			v.selectedIndex = len(v.hosts) - 1
		}
		v.status = "Host deleted successfully"
	}
	return v, nil
}

// W pliku internal/ui/views/main.go
func (v *mainView) handleTransfer() (tea.Model, tea.Cmd) {
	host := v.hosts[v.selectedIndex]
	v.model.SetSelectedHost(&host)

	var authData string
	var err error

	if host.PasswordID < 0 {
		// Obsługa klucza SSH
		keyIndex := -(host.PasswordID + 1) // Konwertujemy ujemny indeks na właściwy indeks klucza
		keys := v.model.GetKeys()
		if keyIndex >= len(keys) {
			v.errMsg = "Invalid SSH key ID"
			return v, nil
		}

		key := keys[keyIndex]
		keyPath, err := key.GetKeyPath()
		if err != nil {
			v.errMsg = fmt.Sprintf("Failed to get key path: %v", err)
			return v, nil
		}
		authData = keyPath
	} else {
		// Obsługa hasła
		passwords := v.model.GetPasswords()
		if host.PasswordID >= len(passwords) {
			v.errMsg = "Invalid password ID"
			return v, nil
		}
		password := passwords[host.PasswordID]
		authData, err = password.GetDecrypted(v.model.GetCipher())
		if err != nil {
			v.errMsg = fmt.Sprintf("Failed to decrypt password: %v", err)
			return v, nil
		}
	}

	transfer := v.model.GetTransfer()
	if err := transfer.Connect(&host, authData); err != nil {
		v.errMsg = fmt.Sprintf("Failed to establish SFTP connection: %v", err)
		return v, nil
	}

	v.model.SetActiveView(ui.ViewTransfer)

	return v, tea.Sequence(
		tea.ClearScreen,
		func() tea.Msg {
			return tea.WindowSizeMsg{
				Width:  v.width,
				Height: v.height,
			}
		},
	)
}

func (v *mainView) View() string {
	// Przygotuj główną zawartość
	var content strings.Builder
	content.WriteString(ui.TitleStyle.Render("SSH Manager") + "\n\n")

	// Główny layout w stylu MC z dwoma panelami
	leftPanel := v.renderHostPanel()
	rightPanel := v.renderDetailsPanel()

	// Połącz panele horyzontalnie
	mainContent := lipgloss.JoinHorizontal(
		lipgloss.Left,
		leftPanel,
		"  +  ", // separator
		rightPanel,
	)

	content.WriteString(mainContent + "\n\n")

	// Status bar i Command bar
	statusAndCmdBar := v.renderStatusBar()
	content.WriteString(statusAndCmdBar + "\n")

	// Zastosuj styl ramki do całej zawartości
	framedContent := ui.WindowStyle.Render(content.String())

	// Podstawowy widok
	baseView := lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Left,
		lipgloss.Top,
		framedContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)

	// Jeśli jest aktywny popup, renderuj go na wierzchu
	if v.popup != nil {
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			baseView+"\n"+v.popup.Render(),
			lipgloss.WithWhitespaceChars(""),
			lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
		)
	}

	return baseView
}

func (v *mainView) renderHostPanel() string {
	style := ui.PanelStyle.Width(45)
	title := "Available Hosts"

	var content strings.Builder
	if len(v.hosts) == 0 {
		content.WriteString(ui.DescriptionStyle.Render("\n  No hosts available\n  Press 'n' to add new host"))
	} else {
		for i, host := range v.hosts {
			prefix := "  "
			var line string

			// Renderujemy nazwę hosta z użyciem HostStyle
			hostName := ui.HostStyle.Render(host.Name)

			if i == v.selectedIndex {
				// Ustawiamy prefix dla zaznaczonego hosta
				prefix = ui.SuccessStyle.Render("❯ ")
				// Budujemy linię z użyciem SelectedItemStyle i HostStyle
				line = ui.SelectedItemStyle.Render(
					fmt.Sprintf("\n%s%s", prefix, hostName),
				)
			} else {
				// Budujemy linię dla niezaznaczonego hosta z HostStyle
				line = fmt.Sprintf("\n%s%s", prefix, hostName)
			}
			// Dodajemy linię do zawartości
			content.WriteString(line)
		}
	}

	return style.Render(title + "\n" + content.String())
}

func (v *mainView) renderDetailsPanel() string {
	style := ui.PanelStyle.Width(45)
	title := "Host Details"

	var content strings.Builder
	if len(v.hosts) > 0 {
		host := v.hosts[v.selectedIndex]
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Name:"), ui.Infotext.Render(host.Name)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Description:"), ui.Infotext.Render(host.Description)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Login:"), ui.Infotext.Render(host.Login)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Address:"), ui.Infotext.Render(host.IP)))
		content.WriteString(fmt.Sprintf("\n  %s %s", ui.LabelStyle.Render("Port:"), ui.Infotext.Render(host.Port)))
	}

	return style.Render(title + "\n" + content.String())
}

func (v *mainView) renderStatusBar() string {
	// Renderowanie paska statusu
	var status string
	if v.errMsg != "" {
		status = ui.ErrorStyle.Render(v.errMsg)
	} else if v.status != "" {
		status = ui.SuccessStyle.Render(v.status)
	} else if v.model.IsConnected() {
		if host := v.model.GetSelectedHost(); host != nil {
			status = ui.SuccessStyle.Render(fmt.Sprintf("Connected to: %s", host.Name))
		}
	} else {
		status = ui.DescriptionStyle.Render("To restore data from local backup press: ctrl + r")
	}

	// Renderowanie tabeli poleceń
	headers := []string{
		"Connect", "Navigate", "Edit Host", "Add Host", "Pass",
		"Transfer", "Delete Host", "List Keys", "Theme", "Quit",
	}
	shortcuts := []string{
		"enter/c", "↑↓/w/s", "e/f4/ESC+4", "h", "p",
		"t", "d/f8/ESC+8", "k", "space", "q/^c",
	}

	// Renderowanie wierszy tabeli
	var TableStyle = func(row, col int) lipgloss.Style {
		switch {
		case row == -1: // Nagłówki
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(ui.Subtle).
				Align(lipgloss.Center)
		default: // Skróty
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(ui.Special)
		}
	}

	cmdTable := table.New().
		Border(lipgloss.NormalBorder()).
		BorderStyle(lipgloss.NewStyle().Foreground(ui.StatusBar)).
		StyleFunc(TableStyle).
		Headers(headers...).
		Row(shortcuts...)

	// Połączenie statusu i tabeli w jedną ramkę
	fullContent := lipgloss.JoinVertical(
		lipgloss.Left,
		status,            // Pasek statusu
		cmdTable.Render(), // Tabela poleceń
	)

	// Dodanie ramki wokół wszystkiego
	framed := lipgloss.NewStyle().
		Border(lipgloss.NormalBorder()).
		BorderForeground(lipgloss.Color("240")).
		Render(fullContent)

	return framed
}

func (v *mainView) handleRestoreBackup() (tea.Model, tea.Cmd) {
	configPath, err := config.GetDefaultConfigPath()
	if err != nil {
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Error",
			fmt.Sprintf("Could not determine config path: %v", err),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil
	}

	keysDir := filepath.Join(filepath.Dir(configPath), config.DefaultKeysDir)
	apiKey, err := v.model.GetConfig().LoadApiKey(v.model.GetCipher())
	if err != nil {
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Error",
			fmt.Sprintf("Failed to load API key: %v", err),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil
	}

	// Najpierw przywróć pliki z backupu
	if err := sync.RestoreFromBackup(configPath, keysDir); err != nil {
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Error",
			fmt.Sprintf("Failed to restore backup: %v", err),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil
	}

	// Wypchnij przywrócone pliki do API (używając obecnego szyfru)
	if err := sync.PushToAPI(apiKey, configPath, keysDir, v.model.GetCipher()); err != nil {
		v.popup = components.NewPopup(
			components.PopupMessage,
			"Error",
			fmt.Sprintf("Failed to push to API: %v", err),
			50,
			7,
			v.width,
			v.height,
		)
		return v, nil
	}

	// Informujemy o sukcesie i restartujemy
	v.popup = components.NewPopup(
		components.PopupMessage,
		"Success",
		"Backup restored and synced with API. Press Enter to restart.",
		50,
		7,
		v.width,
		v.height,
	)

	return v, tea.Sequence(
		func() tea.Msg {
			return messages.ReloadAppMsg{}
		},
	)
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/main_view.go

# Plik /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/transfer.go
package views

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"sync"
	"time"

	"sshManager/internal/ssh"
	"sshManager/internal/ui"
	"sshManager/internal/ui/components"

	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	ltable "github.com/charmbracelet/lipgloss/table"
)

// Dodaj na początku pliku po importach
func getHomeDir() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return "."
	}
	return home
}

// Stałe określające tryby i stany
const (
	localPanelActive  = true
	remotePanelActive = false
	maxVisibleItems   = 20
	headerHeight      = 3
	footerHeight      = 4
)

// FileEntry reprezentuje pojedynczy plik lub katalog
type FileEntry struct {
	name    string
	size    int64
	modTime time.Time
	isDir   bool
	mode    os.FileMode // Dodane pole

}

// Panel reprezentuje panel plików (lokalny lub zdalny)
type Panel struct {
	path          string
	entries       []FileEntry
	selectedIndex int
	scrollOffset  int
	active        bool
}

type transferProgressMsg ssh.TransferProgress

type transferFinishedMsg struct {
	err error
}

// transferView implementuje główny widok transferu plików
type transferView struct {
	model         *ui.Model
	localPanel    Panel
	remotePanel   Panel
	statusMessage string
	errorMessage  string
	connecting    bool
	connected     bool
	transferring  bool
	progress      ssh.TransferProgress
	showHelp      bool
	input         textinput.Model
	mutex         sync.Mutex
	width         int               // Dodane
	height        int               // Dodane
	escPressed    bool              // flaga wskazująca czy ESC został wciśnięty
	escTimeout    *time.Timer       // timer do resetowania stanu ESC
	popup         *components.Popup // Zmieniamy typ na nowy komponent

}
type connectionStatusMsg struct {
	connected bool
	err       error
}

func NewTransferView(model *ui.Model) *transferView {
	input := textinput.New()
	input.Placeholder = "Enter command..."
	input.CharLimit = 255

	v := &transferView{
		model: model,
		localPanel: Panel{
			path:   getHomeDir(),
			active: true,
			entries: []FileEntry{
				{name: "..", isDir: true},
			},
		},
		remotePanel: Panel{
			path:   "~/", // Tymczasowa wartość
			active: false,
			entries: []FileEntry{
				{name: "..", isDir: true},
			},
		},
		input:  input,
		width:  model.GetTerminalWidth(),
		height: model.GetTerminalHeight(),
	}

	// Inicjalizujemy panel lokalny
	if err := v.updateLocalPanel(); err != nil {
		v.errorMessage = fmt.Sprintf("Failed to load local directory: %v", err)
		return v
	}

	// Inicjujemy połączenie SFTP w tle
	if v.model.GetSelectedHost() != nil {
		go func() {
			// Attempt to establish connection
			err := v.ensureConnected()
			if err != nil {
				v.model.Program.Send(connectionStatusMsg{
					connected: false,
					err:       err,
				})
				return
			}

			// Pobierz katalog domowy i zaktualizuj ścieżkę
			transfer := v.model.GetTransfer()
			if homeDir, err := transfer.GetRemoteHomeDir(); err == nil {
				v.remotePanel.path = homeDir
			}

			// Update remote panel
			err = v.updateRemotePanel()
			if err != nil {
				v.model.Program.Send(connectionStatusMsg{
					connected: false,
					err:       err,
				})
				return
			}

			// Send success message
			v.model.Program.Send(connectionStatusMsg{
				connected: true,
				err:       nil,
			})
		}()
	}

	return v
}

// updateLocalPanel odświeża zawartość lokalnego panelu
func (v *transferView) updateLocalPanel() error {
	entries, err := v.readLocalDirectory(v.localPanel.path)
	if err != nil {
		return err
	}
	v.localPanel.entries = entries
	return nil
}

func (v *transferView) readLocalDirectory(path string) ([]FileEntry, error) {
	dir, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer dir.Close()

	fileInfos, err := dir.Readdir(-1)
	if err != nil {
		return nil, err
	}

	// Zawsze zaczynamy od ".." do nawigacji w górę
	entries := []FileEntry{{
		name:    "..",
		isDir:   true,
		modTime: time.Now(),
	}}

	for _, fi := range fileInfos {
		// Pomijamy ukryte pliki zaczynające się od "." (opcjonalnie)
		if !strings.HasPrefix(fi.Name(), ".") || fi.Name() == ".." {
			entries = append(entries, FileEntry{
				name:    fi.Name(),
				size:    fi.Size(),
				modTime: fi.ModTime(),
				isDir:   fi.IsDir(),
				mode:    fi.Mode(), // Dodane

			})
		}
	}

	// Sortowanie: najpierw katalogi, potem pliki, alfabetycznie
	sort.Slice(entries[1:], func(i, j int) bool {
		// Przesuwamy indeksy o 1, bo pomijamy ".."
		i, j = i+1, j+1
		if entries[i].isDir != entries[j].isDir {
			return entries[i].isDir
		}
		return strings.ToLower(entries[i].name) < strings.ToLower(entries[j].name)
	})

	return entries, nil
}

func (v *transferView) Init() tea.Cmd {
	if !v.connected && !v.connecting && v.model.GetSelectedHost() != nil {
		v.connecting = true
		return v.sendConnectionUpdate() // Usuń argument program
	}
	return nil
}

func (v *transferView) updateRemotePanel() error {
	if err := v.ensureConnected(); err != nil {
		return err
	}

	entries, err := v.readRemoteDirectory(v.remotePanel.path)
	if err != nil {
		v.setConnected(false) // Oznacz jako rozłączony w przypadku błędu
		return err
	}
	v.remotePanel.entries = entries
	return nil
}

// readRemoteDirectory czyta zawartość zdalnego katalogu
func (v *transferView) readRemoteDirectory(path string) ([]FileEntry, error) {
	if err := v.ensureConnected(); err != nil {
		return nil, err
	}

	transfer := v.model.GetTransfer()
	fileInfos, err := transfer.ListRemoteFiles(path)
	if err != nil {
		v.setConnected(false)
		return nil, fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Zawsze zaczynamy od ".." do nawigacji w górę
	entries := []FileEntry{{
		name:    "..",
		isDir:   true,
		modTime: time.Now(),
	}}

	for _, fi := range fileInfos {
		if !strings.HasPrefix(fi.Name(), ".") || fi.Name() == ".." {
			entries = append(entries, FileEntry{
				name:    fi.Name(),
				size:    fi.Size(),
				modTime: fi.ModTime(),
				isDir:   fi.IsDir(),
				mode:    fi.Mode(), // Dodane
			})
		}
	}

	// Sortowanie: najpierw katalogi, potem pliki, alfabetycznie
	sort.Slice(entries[1:], func(i, j int) bool {
		i, j = i+1, j+1
		if entries[i].isDir != entries[j].isDir {
			return entries[i].isDir
		}
		return strings.ToLower(entries[i].name) < strings.ToLower(entries[j].name)
	})

	return entries, nil
}

// getActivePanel zwraca aktywny panel
func (v *transferView) getActivePanel() *Panel {
	if v.localPanel.active {
		return &v.localPanel
	}
	return &v.remotePanel
}

// getInactivePanel zwraca nieaktywny panel
func (v *transferView) getInactivePanel() *Panel {
	if v.localPanel.active {
		return &v.remotePanel
	}
	return &v.localPanel
}

// switchActivePanel przełącza aktywny panel
func (v *transferView) switchActivePanel() {
	v.localPanel.active = !v.localPanel.active
	v.remotePanel.active = !v.remotePanel.active
}

func (v *transferView) renderPanel(p *Panel) string {
	var content strings.Builder

	// Oblicz szerokość panelu
	panelWidth := (min(v.width-40, 160) - 3) / 2

	// Zastosuj styl panelu z ramką
	var panelContent strings.Builder

	// Formatowanie i skracanie ścieżki
	pathText := formatPath(p.path, min(40, panelWidth-5))

	// Użycie stylów ścieżki
	pathStyle := inactivePathStyle
	if p.active {
		pathStyle = activePathStyle
	}
	panelContent.WriteString(pathStyle.Render(pathText))
	panelContent.WriteString("\n")

	// Renderowanie listy plików
	filesList := v.renderFileList(
		p.entries[p.scrollOffset:min(p.scrollOffset+maxVisibleItems, len(p.entries))],
		p.selectedIndex-p.scrollOffset,
		p.active,
		panelWidth-2,
	)
	panelContent.WriteString(filesList)

	// Informacja o przewijaniu
	if len(p.entries) > maxVisibleItems {
		panelContent.WriteString(fmt.Sprintf("\nShowing %d-%d of %d items",
			p.scrollOffset+1,
			min(p.scrollOffset+maxVisibleItems, len(p.entries)),
			len(p.entries)))
	}

	// Zastosuj styl całego panelu
	content.WriteString(panelStyle.
		Width(panelWidth).
		BorderForeground(ui.Subtle).
		Render(panelContent.String()))

	return content.String()
}

func (v *transferView) View() string {
	var content strings.Builder
	// Tytuł i status połączenia
	titleContent := ui.TitleStyle.Render("File Transfer")
	if v.connected {
		if host := v.model.GetSelectedHost(); host != nil {
			titleContent += ui.SuccessStyle.Render(
				fmt.Sprintf(" - Connected to %s (%s)", host.Name, host.IP),
			)
		}
	} else if host := v.model.GetSelectedHost(); host != nil {
		if v.connecting {
			titleContent += ui.DescriptionStyle.Render(" - Establishing connection...")
		} else {
			titleContent += ui.ErrorStyle.Render(
				fmt.Sprintf(" - Not connected to %s (%s)", host.Name, host.IP),
			)
		}
	}
	content.WriteString(titleContent + "\n\n")

	// Obsługa stanu łączenia
	if v.connecting {
		connectingContent := ui.DescriptionStyle.Render("Establishing SFTP connection...")
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			ui.WindowStyle.Render(connectingContent),
		)
	}

	// Obsługa widoku pomocy
	if v.showHelp {
		helpContent := ui.DescriptionStyle.Render(helpText)
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			ui.WindowStyle.Render(helpContent),
		)
	}

	// Oblicz szerokość paneli na podstawie szerokości ekranu
	totalWidth := min(v.width-40, 160) // Zmniejszamy szerokość o marginesy (20 z każdej strony)
	panelWidth := (totalWidth - 3) / 2 // 3 to szerokość separatora

	// Renderuj panele
	leftPanel := v.renderPanel(&v.localPanel)
	rightPanel := ""
	if !v.connected {
		rightPanel = ui.ErrorStyle.Render("\n  No SFTP Connection\n  Press 'q' to return and connect to a host first.")
	} else {
		rightPanel = v.renderPanel(&v.remotePanel)
	}

	// Wyrównaj panele
	leftLines := strings.Split(leftPanel, "\n")
	rightLines := strings.Split(rightPanel, "\n")
	maxLines := max(len(leftLines), len(rightLines))

	// Wyrównaj liczbę linii w panelach
	for i := len(leftLines); i < maxLines; i++ {
		leftLines = append(leftLines, strings.Repeat(" ", panelWidth))
	}
	for i := len(rightLines); i < maxLines; i++ {
		rightLines = append(rightLines, strings.Repeat(" ", panelWidth))
	}

	// Połącz panele
	for i := 0; i < maxLines; i++ {
		content.WriteString(leftLines[i])
		content.WriteString(" │ ")
		content.WriteString(rightLines[i])
		content.WriteString("\n")
	}

	// Pasek postępu
	if v.transferring {
		content.WriteString("\n")
		progressBar := v.formatProgressBar(totalWidth)
		content.WriteString(ui.DescriptionStyle.Render(progressBar))
	}

	if v.isWaitingForInput() {
		content.WriteString("\n" + v.input.View())
	}

	footer := v.renderFooter()
	content.WriteString("\n")
	content.WriteString(footer)

	// Renderuj całość w oknie
	finalContent := ui.WindowStyle.Render(content.String())

	// Jeśli jest aktywny popup, renderuj go na wierzchu (wycentrowany)
	if v.popup != nil {
		return lipgloss.Place(
			v.width,
			v.height,
			lipgloss.Center,
			lipgloss.Center,
			finalContent+"\n"+v.popup.Render(),
			lipgloss.WithWhitespaceChars(""),
			lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
		)
	}

	// Główny widok wyrównany do lewego górnego rogu
	return lipgloss.Place(
		v.width,
		v.height,
		lipgloss.Left, // Zmiana z Center na Left
		lipgloss.Top,  // Zmiana z Center na Top
		finalContent,
		lipgloss.WithWhitespaceChars(""),
		lipgloss.WithWhitespaceForeground(lipgloss.Color("0")),
	)
}

// Pomocnicza funkcja do określania maksimum
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// Pomocnicza funkcja min
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// formatSize formatuje rozmiar pliku
func formatSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB",
		float64(size)/float64(div), "KMGTPE"[exp])
}

// navigatePanel obsługuje nawigację w panelu
func (v *transferView) navigatePanel(p *Panel, direction int) {
	if len(p.entries) == 0 {
		p.selectedIndex = 0
		p.scrollOffset = 0
		return
	}

	newIndex := p.selectedIndex + direction

	if newIndex < 0 {
		newIndex = len(p.entries) - 1
	} else if newIndex >= len(p.entries) {
		newIndex = 0
	}

	p.selectedIndex = newIndex

	// Dostosuj przewijanie
	if p.selectedIndex < p.scrollOffset {
		p.scrollOffset = p.selectedIndex
	} else if p.selectedIndex >= p.scrollOffset+maxVisibleItems {
		p.scrollOffset = p.selectedIndex - maxVisibleItems + 1
	}

	// Upewnij się, że scrollOffset nie jest ujemny
	if p.scrollOffset < 0 {
		p.scrollOffset = 0
	}
}

// enterDirectory wchodzi do wybranego katalogu
func (v *transferView) enterDirectory(p *Panel) error {
	if len(p.entries) == 0 || p.selectedIndex >= len(p.entries) {
		return nil
	}

	entry := p.entries[p.selectedIndex]
	if !entry.isDir {
		return nil
	}

	var newPath string
	if entry.name == ".." {
		// Nawigacja do góry
		newPath = filepath.Dir(p.path)
		// Dla Windows możemy potrzebować dodatkowej obsługi ścieżki głównej
		if runtime.GOOS == "windows" && filepath.Dir(newPath) == newPath {
			newPath = filepath.VolumeName(newPath) + "\\"
		}
	} else {
		newPath = filepath.Join(p.path, entry.name)
	}

	// Zapisz poprzednią ścieżkę
	oldPath := p.path
	p.path = newPath

	// Spróbuj odświeżyć zawartość
	var err error
	if p == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	// W przypadku błędu, przywróć poprzednią ścieżkę
	if err != nil {
		p.path = oldPath
		return err
	}

	// Resetuj wybór i przewijanie
	p.selectedIndex = 0
	p.scrollOffset = 0
	return nil
}

func (v *transferView) hasSelectedItems() bool {
	for _, isSelected := range v.getSelectedItems() {
		if isSelected {
			return true
		}
	}
	return false
}

func (v *transferView) getSelectedItems() map[string]bool {
	selected := make(map[string]bool)
	paths := v.model.GetSelectedPaths() // zakładając, że taka metoda istnieje w Model
	for _, path := range paths {
		selected[path] = true
	}
	return selected
}

func (v *transferView) copyFile() tea.Cmd {
	srcPanel := v.getActivePanel()
	dstPanel := v.getInactivePanel()

	// Zbierz wszystkie zaznaczone pliki i foldery
	var itemsToCopy []struct {
		srcPath string
		dstPath string
		isDir   bool
	}

	// Najpierw sprawdź aktualnie wybrany element, jeśli nie ma zaznaczonych
	if !v.hasSelectedItems() {
		if len(srcPanel.entries) == 0 || srcPanel.selectedIndex >= len(srcPanel.entries) {
			v.handleError(fmt.Errorf("no file selected"))
			return nil
		}
		entry := srcPanel.entries[srcPanel.selectedIndex]
		srcPath := filepath.Join(srcPanel.path, entry.name)
		dstPath := filepath.Join(dstPanel.path, entry.name)
		itemsToCopy = append(itemsToCopy, struct {
			srcPath string
			dstPath string
			isDir   bool
		}{srcPath, dstPath, entry.isDir})
	} else {
		// Dodaj wszystkie zaznaczone elementy
		for path, isSelected := range v.getSelectedItems() {
			if isSelected {
				baseName := filepath.Base(path)
				dstPath := filepath.Join(dstPanel.path, baseName)
				// Sprawdź czy to folder czy plik
				info, err := os.Stat(path)
				if err != nil {
					v.handleError(fmt.Errorf("cannot access %s: %v", path, err))
					continue
				}
				itemsToCopy = append(itemsToCopy, struct {
					srcPath string
					dstPath string
					isDir   bool
				}{path, dstPath, info.IsDir()})
			}
		}
	}

	if len(itemsToCopy) == 0 {
		v.handleError(fmt.Errorf("no items to copy"))
		return nil
	}

	v.mutex.Lock()
	v.transferring = true
	v.statusMessage = "Copying files..."
	v.mutex.Unlock()

	transfer := v.model.GetTransfer()

	// Zwróć komendę rozpoczynającą transfer
	return func() tea.Msg {
		progressChan := make(chan ssh.TransferProgress)
		doneChan := make(chan error, 1)

		// Uruchom transfer w goroutine
		go func() {
			var totalErr error
			for _, item := range itemsToCopy {
				var err error
				if item.isDir {
					if srcPanel == &v.localPanel {
						err = v.copyDirectoryToRemote(item.srcPath, item.dstPath, transfer, progressChan)
					} else {
						err = v.copyDirectoryFromRemote(item.srcPath, item.dstPath, transfer, progressChan)
					}
				} else {
					if srcPanel == &v.localPanel {
						err = transfer.UploadFile(item.srcPath, item.dstPath, progressChan)
					} else {
						err = transfer.DownloadFile(item.srcPath, item.dstPath, progressChan)
					}
				}
				if err != nil {
					totalErr = fmt.Errorf("error copying %s: %v", item.srcPath, err)
					break
				}
			}
			doneChan <- totalErr
			close(progressChan)
		}()

		// Goroutine do czytania postępu i wysyłania wiadomości
		go func() {
			for progress := range progressChan {
				v.model.Program.Send(transferProgressMsg(progress))
			}
			err := <-doneChan
			v.model.Program.Send(transferFinishedMsg{err: err})
			// Wyczyść zaznaczenie po zakończeniu
			v.model.ClearSelection()
		}()

		return nil
	}
}

// Dodaj nowe funkcje do obsługi kopiowania folderów
func (v *transferView) copyDirectoryToRemote(localPath, remotePath string, transfer *ssh.FileTransfer, progressChan chan<- ssh.TransferProgress) error {
	// Utwórz katalog na zdalnym serwerze
	if err := transfer.CreateRemoteDirectory(remotePath); err != nil {
		return fmt.Errorf("failed to create remote directory: %v", err)
	}

	// Przejdź przez wszystkie pliki w lokalnym katalogu
	return filepath.Walk(localPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Oblicz względną ścieżkę
		relPath, err := filepath.Rel(localPath, path)
		if err != nil {
			return err
		}

		// Utwórz pełną ścieżkę zdalną
		remotePathFull := filepath.Join(remotePath, relPath)

		if info.IsDir() {
			// Utwórz katalog na zdalnym serwerze
			return transfer.CreateRemoteDirectory(remotePathFull)
		} else {
			// Prześlij plik
			return transfer.UploadFile(path, remotePathFull, progressChan)
		}
	})
}

func (v *transferView) copyDirectoryFromRemote(remotePath, localPath string, transfer *ssh.FileTransfer, progressChan chan<- ssh.TransferProgress) error {
	// Utwórz lokalny katalog
	if err := os.MkdirAll(localPath, 0755); err != nil {
		return fmt.Errorf("failed to create local directory: %v", err)
	}

	// Pobierz listę plików z katalogu zdalnego
	entries, err := transfer.ListRemoteFiles(remotePath)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Rekurencyjnie kopiuj zawartość
	for _, entry := range entries {
		remoteSrcPath := filepath.Join(remotePath, entry.Name())
		localDstPath := filepath.Join(localPath, entry.Name())

		if entry.IsDir() {
			if err := v.copyDirectoryFromRemote(remoteSrcPath, localDstPath, transfer, progressChan); err != nil {
				return err
			}
		} else {
			if err := transfer.DownloadFile(remoteSrcPath, localDstPath, progressChan); err != nil {
				return err
			}
		}
	}

	return nil
}

// executeDelete wykonuje faktyczne usuwanie pliku
func (v *transferView) executeDelete() error {
	panel := v.getActivePanel()
	entry := panel.entries[panel.selectedIndex]
	path := filepath.Join(panel.path, entry.name)

	var err error
	itemType := "file"
	if entry.isDir {
		itemType = "directory"
	}

	if panel == &v.localPanel {
		if entry.isDir {
			err = os.RemoveAll(path)
		} else {
			err = os.Remove(path)
		}
	} else {
		transfer := v.model.GetTransfer()
		if entry.isDir {
			// Rekursywne usuwanie katalogu na zdalnym serwerze
			err = v.removeRemoteDirectory(path, transfer)
		} else {
			err = transfer.RemoveRemoteFile(path)
		}
	}

	if err != nil {
		return fmt.Errorf("failed to delete %s '%s': %v", itemType, entry.name, err)
	}

	// Odśwież panel po usunięciu
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Deleted %s '%s'", itemType, entry.name)
	return nil
}

func (v *transferView) removeRemoteDirectory(path string, transfer *ssh.FileTransfer) error {
	// Pobierz listę plików w katalogu
	entries, err := transfer.ListRemoteFiles(path)
	if err != nil {
		return fmt.Errorf("failed to list remote directory: %v", err)
	}

	// Rekurencyjnie usuń zawartość katalogu
	for _, entry := range entries {
		if entry.Name() == "." || entry.Name() == ".." {
			continue
		}

		fullPath := filepath.Join(path, entry.Name())
		if entry.IsDir() {
			// Rekurencyjnie usuń podkatalog
			if err := v.removeRemoteDirectory(fullPath, transfer); err != nil {
				return err
			}
		} else {
			// Usuń plik
			if err := transfer.RemoveRemoteFile(fullPath); err != nil {
				return err
			}
		}
	}

	// Na końcu usuń sam katalog
	return transfer.RemoveRemoteFile(path)
}

// createDirectory tworzy nowy katalog
func (v *transferView) createDirectory(name string) error {
	if name == "" {
		return fmt.Errorf("directory name cannot be empty")
	}

	// Sprawdź czy nazwa nie zawiera niedozwolonych znaków
	if strings.ContainsAny(name, "/\\") {
		return fmt.Errorf("directory name cannot contain path separators")
	}

	panel := v.getActivePanel()
	path := filepath.Join(panel.path, name)

	var err error
	if panel == &v.localPanel {
		err = os.MkdirAll(path, 0755)
	} else {
		if !v.connected {
			return fmt.Errorf("not connected to remote host")
		}
		transfer := v.model.GetTransfer()
		err = transfer.CreateRemoteDirectory(path)
	}

	if err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Odśwież panel
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Created directory '%s'", name)
	return nil
}

// renameFile zmienia nazwę pliku
func (v *transferView) renameFile(newName string) error {
	if newName == "" {
		return fmt.Errorf("new name cannot be empty")
	}

	panel := v.getActivePanel()
	if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
		return fmt.Errorf("no file selected")
	}

	entry := panel.entries[panel.selectedIndex]
	if entry.name == ".." {
		return fmt.Errorf("cannot rename parent directory reference")
	}

	oldPath := filepath.Join(panel.path, entry.name)
	newPath := filepath.Join(panel.path, newName)

	var err error
	if panel == &v.localPanel {
		err = os.Rename(oldPath, newPath)
	} else {
		transfer := v.model.GetTransfer()
		err = transfer.RenameRemoteFile(oldPath, newPath)
	}

	if err != nil {
		return fmt.Errorf("failed to rename file: %v", err)
	}

	// Odśwież panel
	if panel == &v.localPanel {
		err = v.updateLocalPanel()
	} else {
		err = v.updateRemotePanel()
	}

	if err != nil {
		return fmt.Errorf("failed to refresh panel: %v", err)
	}

	v.statusMessage = fmt.Sprintf("Renamed %s to %s", entry.name, newName)
	return nil
}

// handleError obsługuje błędy i wyświetla komunikat
func (v *transferView) handleError(err error) {
	if err != nil {
		v.errorMessage = err.Error()
	}
}

// update

func (v *transferView) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		v.mutex.Lock()
		v.width = msg.Width
		v.height = msg.Height
		v.model.UpdateWindowSize(msg.Width, msg.Height)
		v.mutex.Unlock()
		return v, nil

	case transferProgressMsg:
		v.mutex.Lock()
		v.progress = ssh.TransferProgress(msg)
		v.mutex.Unlock()
		return v, nil

	case transferFinishedMsg:
		v.mutex.Lock()
		v.transferring = false
		if msg.err != nil {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Transfer Error",
				fmt.Sprintf("Transfer error: %v", msg.err),
				50,
				7,
				v.width,
				v.height,
			)
		} else {
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Success",
				"Transfer completed successfully",
				50,
				7,
				v.width,
				v.height,
			)
			dstPanel := v.getInactivePanel()
			if dstPanel == &v.localPanel {
				v.updateLocalPanel()
			} else {
				v.updateRemotePanel()
			}
		}
		v.mutex.Unlock()
		return v, nil

	case connectionStatusMsg:
		v.mutex.Lock()
		v.connecting = false
		if msg.err != nil {
			v.connected = false
			v.popup = components.NewPopup(
				components.PopupMessage,
				"Connection Error",
				fmt.Sprintf("Connection error: %v", msg.err),
				50,
				7,
				v.width,
				v.height,
			)
		} else {
			v.connected = msg.connected
		}
		v.mutex.Unlock()
		return v, nil

	case tea.KeyMsg:
		// Obsługa popupu
		if v.popup != nil {
			switch msg.String() {
			case "esc":
				v.popup = nil
				return v, nil
			case "enter":
				if v.popup.Type != components.PopupDelete {
					// Użyj v.popup.Input zamiast v.input
					if err := v.handleCommand(v.popup.Input.Value()); err != nil {
						v.handleError(err)
					}
					v.popup = nil
					return v, nil
				}
			case "y":
				if v.popup.Type == components.PopupDelete {
					if err := v.executeDelete(); err != nil {
						v.handleError(err)
					}
					v.popup = nil
					return v, nil
				}
			case "n":
				if v.popup.Type == components.PopupDelete {
					v.popup = nil
					return v, nil
				}
			default:
				if v.popup.Type != components.PopupDelete {
					var cmd tea.Cmd
					// Aktualizuj v.popup.Input zamiast v.input
					v.popup.Input, cmd = v.popup.Input.Update(msg)
					return v, cmd
				}
			}
			return v, nil
		}
		// Obsługa trybu pomocy
		if v.showHelp {
			switch msg.String() {
			case "esc", "q", "f1":
				v.showHelp = false
				return v, nil
			default:
				return v, nil // Ignoruj inne klawisze w trybie pomocy
			}
		}

		// Obsługa sekwencji ESC
		if v.escPressed {
			switch msg.String() {
			case "0", "q":
				if v.transferring {
					return v, nil
				}
				if v.connected {
					transfer := v.model.GetTransfer()
					if transfer != nil {
						transfer.Disconnect()
					}
				}
				v.model.SetActiveView(ui.ViewMain)
				return v, nil

			case "5":
				if !v.transferring {
					cmd := v.copyFile()
					v.escPressed = false
					if v.escTimeout != nil {
						v.escTimeout.Stop()
					}
					return v, cmd
				}

			case "6":
				if !v.transferring {
					v.popup = components.NewPopup(
						components.PopupRename,
						"Rename",
						"Enter new name:",
						50,
						7,
						v.width,
						v.height,
					)
					v.popup.Input.SetValue("")
					v.popup.Input.Focus()
				}
				return v, nil

			case "7":
				if !v.transferring {
					v.popup = components.NewPopup(
						components.PopupMkdir,
						"Create Directory",
						"Enter directory name:",
						50,
						7,
						v.width,
						v.height,
					)
					v.popup.Input.SetValue("")
					v.popup.Input.Focus()
				}
				return v, nil

			case "8":
				if !v.transferring {
					panel := v.getActivePanel()
					if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
						return v, nil
					}
					entry := panel.entries[panel.selectedIndex]
					if entry.name == ".." {
						return v, nil
					}
					v.popup = components.NewPopup(
						components.PopupDelete,
						"Delete",
						fmt.Sprintf("Delete %s '%s'? (y/n)",
							map[bool]string{true: "directory", false: "file"}[entry.isDir],
							entry.name),
						50,
						7,
						v.width,
						v.height,
					)
				}
				return v, nil
			}
			// Reset stan}u ESC
			v.escPressed = false
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			return v, nil
		}

		// Pojedyncze naciśnięcie ESC
		if msg.String() == "esc" {
			if v.popup != nil {
				v.popup = nil
				return v, nil
			}
			v.escPressed = true
			if v.escTimeout != nil {
				v.escTimeout.Stop()
			}
			v.escTimeout = time.NewTimer(500 * time.Millisecond)
			go func() {
				<-v.escTimeout.C
				v.escPressed = false
			}()
			return v, nil
		}

		// Standardowe klawisze funkcyjne
		switch msg.String() {
		case " ": // dodajemy jako pierwszy case
			if !v.transferring {
				ui.SwitchTheme()
				return v, nil
			}
		case "f1":
			v.showHelp = !v.showHelp
			return v, nil

		case "f5", "c":
			if !v.transferring {
				cmd := v.copyFile()
				return v, cmd
			}
			return v, nil

		case "f6", "r":
			if !v.transferring {
				v.popup = components.NewPopup(
					components.PopupRename,
					"Rename",
					"Enter new name:",
					50,
					7,
					v.width,
					v.height,
				)
				v.popup.Input.SetValue("")
				v.popup.Input.Focus()
			}
			return v, nil

		case "f7", "m":
			if !v.transferring {
				v.popup = components.NewPopup(
					components.PopupMkdir,
					"Create Directory",
					"Enter directory name:",
					50,
					7,
					v.width,
					v.height,
				)
				v.popup.Input.SetValue("")
				v.popup.Input.Focus()
			}
			return v, nil

		case "f8", "d":
			if !v.transferring {
				panel := v.getActivePanel()
				if len(panel.entries) == 0 || panel.selectedIndex >= len(panel.entries) {
					return v, nil
				}
				entry := panel.entries[panel.selectedIndex]
				if entry.name == ".." {
					return v, nil
				}
				v.popup = components.NewPopup(
					components.PopupDelete,
					"Delete",
					fmt.Sprintf("Delete %s '%s'? (y/n)",
						map[bool]string{true: "directory", false: "file"}[entry.isDir],
						entry.name),
					50,
					7,
					v.width,
					v.height,
				)
			}
			return v, nil

		// Standardowe klawisze nawigacji i kontroli
		case "q":
			if v.transferring {
				return v, nil
			}
			if v.connected {
				transfer := v.model.GetTransfer()
				if transfer != nil {
					transfer.Disconnect()
				}
			}
			v.model.SetActiveView(ui.ViewMain)
			return v, nil

		case "tab":
			if v.connected {
				v.switchActivePanel()
				v.errorMessage = ""
			}
			return v, nil

		case "up", "k":
			panel := v.getActivePanel()
			v.navigatePanel(panel, -1)
			v.errorMessage = ""
			return v, nil

		case "down", "j":
			panel := v.getActivePanel()
			v.navigatePanel(panel, 1)
			v.errorMessage = ""
			return v, nil

		case "enter":
			panel := v.getActivePanel()
			if err := v.enterDirectory(panel); err != nil {
				v.popup = components.NewPopup(
					components.PopupMessage,
					"Error",
					err.Error(),
					50,
					7,
					v.width,
					v.height,
				)
			}
			return v, nil

		case "s":
			if !v.transferring {
				panel := v.getActivePanel()
				if len(panel.entries) > 0 && panel.selectedIndex < len(panel.entries) {
					entry := panel.entries[panel.selectedIndex]
					path := filepath.Join(panel.path, entry.name)
					if entry.name != ".." {
						v.model.ToggleSelection(path)
					}
				}
			}
			return v, nil

		}

	case ssh.TransferProgress:
		v.progress = msg
		return v, nil
	}

	return v, nil
}

// handleCommand obsługuje wprowadzanie komend
func (v *transferView) handleCommand(cmd string) error {
	if v.popup == nil {
		return fmt.Errorf("no active popup")
	}

	switch v.popup.Type { // użycie Type zamiast promptType
	case components.PopupRename: // użycie components.PopupRename zamiast promptRename
		err := v.renameFile(cmd)
		v.popup = nil
		return err
	case components.PopupMkdir: // użycie components.PopupMkdir zamiast promptMkdir
		err := v.createDirectory(cmd)
		v.popup = nil
		return err
	default:
		v.popup = nil
		return fmt.Errorf("unknown command")
	}
}

// internal/ui/views/transfer.go

func (v *transferView) formatProgressBar(width int) string {
	if !v.transferring || v.progress.TotalBytes == 0 {
		return ""
	}

	percentage := float64(v.progress.TransferredBytes) / float64(v.progress.TotalBytes)
	barWidth := width - 30 // Zostaw miejsce na procenty i prędkość
	completedWidth := int(float64(barWidth) * percentage)

	bar := fmt.Sprintf("[%s%s] %3.0f%%",
		strings.Repeat("=", completedWidth),
		strings.Repeat(" ", barWidth-completedWidth),
		percentage*100)

	elapsed := time.Since(v.progress.StartTime).Seconds()
	if elapsed == 0 {
		elapsed = 1 // Zapobieganie dzieleniu przez zero
	}
	speed := float64(v.progress.TransferredBytes) / elapsed

	return fmt.Sprintf("%s %s %s/s",
		v.progress.FileName,
		bar,
		formatSize(int64(speed)))
}

// shouldShowDeleteConfirm sprawdza czy wyświetlić potwierdzenie usunięcia
func (v *transferView) shouldShowDeleteConfirm() bool {
	return strings.HasPrefix(v.statusMessage, "Delete ")
}

// isWaitingForInput sprawdza czy oczekuje na wprowadzenie tekstu
func (v *transferView) isWaitingForInput() bool {
	return strings.HasPrefix(v.statusMessage, "Enter ")
}

var helpText = `
 File Transfer Help
 -----------------
 Tab          - Switch panel
 Enter        - Enter directory
 F5/ESC+5/c   - Copy file
 F6/ESC+6/r   - Rename
 F7/ESC+7/m   - Create directory
 F8/ESC+8/d   - Delete
 F1           - Toggle help
 Ctrl+r       - Refresh
 q/ESC+0      - Exit
 s            - Select/Unselect file

 Navigation
 ----------
 Up/k         - Move up
 Down/j       - Move down
`

func (v *transferView) renderShortcuts() string {
	// Nagłówki tabeli i skróty
	headers := []string{"Switch Panel", "Select", "Copy", "Rename", "MkDir", "Delete", "Help", "Theme", "Exit"}
	shortcuts := []string{"[Tab]", "[s]", "[F5|ESC+5|c]", "[F6|ESC+6|r]", "[F7|ESC+7|m]", "[F8|ESC+8|d]", "[F1]", "[space]", "[q|ESC+0]"}

	// Funkcja stylizująca kolumny
	var TableStyle = func(row, col int) lipgloss.Style {
		switch {
		case row == 0: // Nagłówki
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(ui.Subtle).
				Align(lipgloss.Center)
		default: // Skróty
			return lipgloss.NewStyle().
				Padding(0, 1).
				Foreground(ui.Special).
				Align(lipgloss.Center)
		}
	}

	// Tworzenie tabeli
	cmdTable := ltable.New().
		Border(lipgloss.NormalBorder()).
		BorderStyle(lipgloss.NewStyle().Foreground(ui.StatusBar)).
		StyleFunc(TableStyle).
		Headers(headers...).
		Row(shortcuts...)

	// Renderowanie tabeli
	return cmdTable.Render()
}

// Funkcja pomocnicza do budowania wierszy

// Pomocnicze stałe dla kolorów i stylów
var (
	panelBorder = lipgloss.Border{
		Top:         "─",
		Bottom:      "─",
		Left:        "│",
		Right:       "│",
		TopLeft:     "┌",
		TopRight:    "┐",
		BottomLeft:  "└",
		BottomRight: "┘",
	}

	panelStyle = lipgloss.NewStyle().
			Border(panelBorder).
			BorderForeground(ui.Subtle).
			Padding(0, 1).
			Height(20) // Dodaj stałą wysokość

	activePathStyle = lipgloss.NewStyle().
			Bold(true).
			Background(ui.Highlight).
			Foreground(lipgloss.Color("0"))

	inactivePathStyle = lipgloss.NewStyle().
				Foreground(ui.Subtle)
)

// formatPath formatuje ścieżkę do wyświetlenia
func formatPath(path string, maxWidth int) string {
	if len(path) <= maxWidth {
		return path
	}

	// Dodaj "..." na początku jeśli ścieżka jest za długa
	return "..." + path[len(path)-(maxWidth-3):]
}

func getFileType(entry FileEntry) string {
	if entry.isDir {
		return "directory"
	}

	// Określenie typu na podstawie rozszerzenia
	ext := strings.ToLower(filepath.Ext(entry.name))

	// Archiwa
	switch ext {
	case ".zip", ".tar", ".gz", ".bz2", ".xz", ".7z", ".rar":
		return "archive"
	}

	// Obrazy
	switch ext {
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".webp":
		return "image"
	}

	// Dokumenty
	switch ext {
	case ".txt", ".doc", ".docx", ".pdf", ".md", ".csv", ".xlsx", ".odt":
		return "document"
	}

	// Pliki wykonywalne
	switch ext {
	case ".exe", ".sh", ".bat", ".cmd", ".com", ".app":
		return "executable"
	}

	// Pliki kodu
	switch ext {
	case ".c":
		return "code_c"
	case ".h":
		return "code_h"
	case ".go":
		return "code_go"
	case ".py":
		return "code_py"
	case ".js":
		return "code_js"
	case ".json":
		return "code_json"
		// Możesz dodać więcej rozszerzeń dla innych języków programowania tutaj
	}

	// Jeśli plik ma ustawione prawa wykonywania
	if entry.mode&0111 != 0 {
		return "executable"
	}

	return "default"
}

// internal/ui/views/transfer.go
// internal/ui/views/transfer.go

func (v *transferView) renderFileList(entries []FileEntry, selected int, _ bool, width int) string {
	t := table.New(
		table.WithColumns([]table.Column{
			{Title: " ", Width: 2}, // Kolumna na gwiazdkę
			{Title: "Name", Width: width - 37},
			{Title: "Size", Width: 10},
			{Title: "Modified", Width: 19},
		}),
	)

	var rows []table.Row
	for _, entry := range entries {
		path := filepath.Join(v.getActivePanel().path, entry.name)
		isMarked := v.model.IsSelected(path)

		// Tworzenie wiersza
		prefix := " "
		if isMarked {
			prefix = "*"
		}

		name := entry.name
		if entry.isDir {
			name = "[" + name + "]"
		}

		row := table.Row{
			prefix,
			name,
			formatSize(entry.size),
			entry.modTime.Format("2006-01-02 15:04"),
		}
		rows = append(rows, row)
	}

	t.SetRows(rows)

	// Renderujemy tabelę
	tableOutput := t.View()

	// Teraz dodajemy kolory linijka po linijce
	var coloredOutput strings.Builder
	lines := strings.Split(tableOutput, "\n")

	for i, line := range lines {
		// Pomijamy linie nagłówka (pierwsza linia)
		if i == 0 {
			coloredOutput.WriteString(line + "\n")
			continue
		}

		// Sprawdzamy czy ta linia odpowiada jakiemuś plikowi
		entryIndex := i - 1 // odejmujemy 1 bo pierwsza linia to nagłówek
		if entryIndex >= 0 && entryIndex < len(entries) {
			entry := entries[entryIndex]
			var style lipgloss.Style

			// Specjalne traktowanie linii ".."
			if entry.name == ".." {
				if entryIndex == selected {
					// Ten sam styl dla aktywnego i nieaktywnego panelu gdy ".." jest zaznaczone
					style = lipgloss.NewStyle().
						Bold(true).
						Background(ui.Highlight).
						Foreground(lipgloss.Color("0"))
				} else {
					style = ui.DirectoryStyle
				}
			} else if entryIndex == selected {
				// Ten sam styl dla zaznaczenia w obu panelach
				style = lipgloss.NewStyle().
					Bold(true).
					Background(ui.Highlight).
					Foreground(lipgloss.Color("0"))
			} else if entry.isDir {
				// Katalogi zawsze używają DirectoryStyle
				style = ui.DirectoryStyle
			} else {
				switch getFileType(entry) {
				case "executable":
					style = ui.ExecutableStyle
				case "archive":
					style = ui.ArchiveStyle
				case "image":
					style = ui.ImageStyle
				case "document":
					style = ui.DocumentStyle
				case "code_c":
					style = ui.CodeCStyle
				case "code_h":
					style = ui.CodeHStyle
				case "code_go":
					style = ui.CodeGoStyle
				case "code_py":
					style = ui.CodePyStyle
				case "code_js":
					style = ui.CodeJsStyle
				case "code_json":
					style = ui.CodeJsonStyle
				default:
					if strings.HasPrefix(getFileType(entry), "code_") {
						style = ui.CodeDefaultStyle
					} else {
						style = ui.DefaultFileStyle
					}
				}
			}
			coloredOutput.WriteString(style.Render(line) + "\n")
		} else {
			coloredOutput.WriteString(line + "\n")
		}
	}

	return coloredOutput.String()
}

func (v *transferView) ensureConnected() error {
	transfer := v.model.GetTransfer()
	if transfer == nil {
		return fmt.Errorf("no transfer client available")
	}

	host := v.model.GetSelectedHost()
	if host == nil {
		return fmt.Errorf("no host selected")
	}

	var authData string

	if host.PasswordID < 0 {
		// Obsługa klucza SSH
		keyIndex := -(host.PasswordID + 1)
		keys := v.model.GetKeys()
		if keyIndex >= len(keys) {
			return fmt.Errorf("invalid key ID")
		}

		key := keys[keyIndex]
		keyPath, pathErr := key.GetKeyPath()
		if pathErr != nil {
			return fmt.Errorf("failed to get key path: %v", pathErr)
		}
		authData = keyPath
	} else {
		// Obsługa hasła
		passwords := v.model.GetPasswords()
		if host.PasswordID >= len(passwords) {
			return fmt.Errorf("invalid password ID")
		}

		password := passwords[host.PasswordID]
		decryptedPass, decErr := password.GetDecrypted(v.model.GetCipher())
		if decErr != nil {
			return fmt.Errorf("failed to decrypt password: %v", decErr)
		}
		authData = decryptedPass
	}

	if err := transfer.Connect(host, authData); err != nil {
		return fmt.Errorf("failed to establish SFTP connection: %v", err)
	}

	return nil
}

func (v *transferView) setConnected(connected bool) {
	v.mutex.Lock()
	defer v.mutex.Unlock()
	v.connected = connected
}

func (v *transferView) sendConnectionUpdate() tea.Cmd {
	return func() tea.Msg {
		return connectionStatusMsg{
			connected: v.connected,
			err:       nil,
		}
	}
}

func (v *transferView) renderFooter() string {
	var footerContent strings.Builder

	// Komunikat o błędzie
	if v.errorMessage != "" {
		footerContent.WriteString(ui.ErrorStyle.Render("Error: " + v.errorMessage))
		footerContent.WriteString("\n")
	}

	// Status
	if v.statusMessage != "" {
		style := ui.DescriptionStyle
		if v.shouldShowDeleteConfirm() {
			style = ui.ErrorStyle
		} else if v.isWaitingForInput() {
			style = ui.InputStyle
		}
		footerContent.WriteString(style.Render(v.statusMessage))
		footerContent.WriteString("\n")
	}

	// Komunikat o braku połączenia
	if !v.connected && v.errorMessage == "" {
		footerContent.WriteString(ui.ErrorStyle.Render(
			"SFTP connection not established. Press 'q' to return to main menu and connect first."))
		footerContent.WriteString("\n")
	}

	// Skróty klawiszowe
	if v.connected {
		footerContent.WriteString(v.renderShortcuts())
	} else {
		footerContent.WriteString(ui.ButtonStyle.Render("q") + " - Return to main menu")
	}

	return footerContent.String()
}

# Koniec /Users/kfn/Desktop/DEV/sshManager/internal/ui//views/transfer.go

